<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>51-100.md—F:\e\算法\leetcode刷题记录</title>
    <style type="text/css">
    html{font-family: sans-serif;-ms-text-size-adjust: 100%;-webkit-text-size-adjust: 100%}body{margin: 0}article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display: block}audio,canvas,progress,video{display: inline-block;vertical-align: baseline}audio:not([controls]){display: none;height: 0}[hidden],template{display: none}a{background: transparent}a:active,a:hover{outline: 0}abbr[title]{border-bottom: 1px dotted}b,strong{font-weight: bold}dfn{font-style: italic}h1{font-size: 2em;margin: 0.67em 0}mark{background: #ff0;color: #000}small{font-size: 80%}sub,sup{font-size: 75%;line-height: 0;position: relative;vertical-align: baseline}sup{top: -0.5em}sub{bottom: -0.25em}img{border: 0}svg:not(:root){overflow: hidden}figure{margin: 1em 40px}hr{box-sizing: content-box;height: 0}pre{overflow: auto}code,kbd,pre,samp{font-family: monospace, monospace;font-size: 1em}button,input,optgroup,select,textarea{color: inherit;font: inherit;margin: 0}button{overflow: visible}button,select{text-transform: none}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance: button;cursor: pointer}button[disabled],html input[disabled]{cursor: default}button::-moz-focus-inner,input::-moz-focus-inner{border: 0;padding: 0}input{line-height: normal}input[type="checkbox"],input[type="radio"]{box-sizing: border-box;padding: 0}input[type="number"]::-webkit-inner-spin-button,input[type="number"]::-webkit-outer-spin-button{height: auto}input[type="search"]{-webkit-appearance: textfield;box-sizing: content-box}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance: none}fieldset{border: 1px solid #c0c0c0;margin: 0 2px;padding: 0.35em 0.625em 0.75em}legend{border: 0;padding: 0}textarea{overflow: auto}optgroup{font-weight: bold}table{border-collapse: collapse;border-spacing: 0}td,th{padding: 0}*{box-sizing: border-box}input,select,textarea,button{font: 13px/1.4 Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"}body{min-width: 1020px;font: 13px/1.4 Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";color: #333;background-color: #fff}a{color: #4183c4;text-decoration: none}a:hover,a:active{text-decoration: underline}hr,.rule{height: 0;margin: 15px 0;overflow: hidden;background: transparent;border: 0;border-bottom: 1px solid #ddd}hr:before,.rule:before{display: table;content: ""}hr:after,.rule:after{display: table;clear: both;content: ""}h1,h2,h3,h4,h5,h6{margin-top: 15px;margin-bottom: 15px;line-height: 1.1}h1{font-size: 30px}h2{font-size: 21px}h3{font-size: 16px}h4{font-size: 14px}h5{font-size: 12px}h6{font-size: 11px}small{font-size: 90%}blockquote{margin: 0}.lead{margin-bottom: 30px;font-size: 20px;font-weight: 300;color: #555}.text-muted{color: #999}.text-danger{color: #bd2c00}.text-emphasized{font-weight: bold;color: #333}ul,ol{padding: 0;margin-top: 0;margin-bottom: 0}ol ol,ul ol{list-style-type: lower-roman}ul ul ol,ul ol ol,ol ul ol,ol ol ol{list-style-type: lower-alpha}dd{margin-left: 0}tt,code{font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;font-size: 12px}pre{margin-top: 0;margin-bottom: 0;font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace}#realtime .status{overflow: visible;position: absolute;top: -5px;left: 0;background: url("/public/images/github-status.png");width: 26px;height: 26px;display: block;margin: 0 5px 0 0}#realtime .up{background-position: 0 0}#realtime .problem{background-position: 0 -53px}#realtime .down{background-position: 0 -26px}.container{max-width: 920px;margin: 0 auto 20px auto}#header{background: #FAFAFA;background: -moz-linear-gradient(#FAFAFA, #EAEAEA);background: -webkit-linear-gradient(#FAFAFA, #EAEAEA);-ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr='#fafafa', endColorstr='#eaeaea')";border-bottom: 1px solid #CACACA;box-shadow: 0 1px 0 rgba(255, 255, 255, 0.4),0 0 10px rgba(0, 0, 0, 0.1)}#markup{padding: 3px}#markup article{padding-top: 30px}.markdown-body{overflow: hidden;font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;font-size: 16px;line-height: 1.6;word-wrap: break-word}.markdown-body>*:first-child{margin-top: 0 !important}.markdown-body>*:last-child{margin-bottom: 0 !important}.markdown-body .absent{color: #c00}.markdown-body .anchor{position: absolute;top: 0;left: 0;display: block;padding-right: 6px;padding-left: 30px;margin-left: -30px}.markdown-body .anchor:focus{outline: none}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{position: relative;margin-top: 1em;margin-bottom: 16px;font-weight: bold;line-height: 1.4}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{display: none;color: #000;vertical-align: middle}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{padding-left: 8px;margin-left: -30px;text-decoration: none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{display: inline-block}.markdown-body h1 tt,.markdown-body h1 code,.markdown-body h2 tt,.markdown-body h2 code,.markdown-body h3 tt,.markdown-body h3 code,.markdown-body h4 tt,.markdown-body h4 code,.markdown-body h5 tt,.markdown-body h5 code,.markdown-body h6 tt,.markdown-body h6 code{font-size: inherit}.markdown-body h1{padding-bottom: 0.3em;font-size: 2.25em;line-height: 1.2;border-bottom: 1px solid #eee}.markdown-body h1 .anchor{line-height: 1}.markdown-body h2{padding-bottom: 0.3em;font-size: 1.75em;line-height: 1.225;border-bottom: 1px solid #eee}.markdown-body h2 .anchor{line-height: 1}.markdown-body h3{font-size: 1.5em;line-height: 1.43}.markdown-body h3 .anchor{line-height: 1.2}.markdown-body h4{font-size: 1.25em}.markdown-body h4 .anchor{line-height: 1.2}.markdown-body h5{font-size: 1em}.markdown-body h5 .anchor{line-height: 1.1}.markdown-body h6{font-size: 1em;color: #777}.markdown-body h6 .anchor{line-height: 1.1}.markdown-body p,.markdown-body blockquote,.markdown-body ul,.markdown-body ol,.markdown-body dl,.markdown-body table,.markdown-body pre{margin-top: 0;margin-bottom: 16px}.markdown-body hr{height: 4px;padding: 0;margin: 16px 0;background-color: #e7e7e7;border: 0 none}.markdown-body ul,.markdown-body ol{padding-left: 2em}.markdown-body ul.no-list,.markdown-body ol.no-list{padding: 0;list-style-type: none}.markdown-body ul ul,.markdown-body ul ol,.markdown-body ol ol,.markdown-body ol ul{margin-top: 0;margin-bottom: 0}.markdown-body li>p{margin-top: 16px}.markdown-body dl{padding: 0}.markdown-body dl dt{padding: 0;margin-top: 16px;font-size: 1em;font-style: italic;font-weight: bold}.markdown-body dl dd{padding: 0 16px;margin-bottom: 16px}.markdown-body blockquote{padding: 0 15px;color: #777;border-left: 4px solid #ddd}.markdown-body blockquote>:first-child{margin-top: 0}.markdown-body blockquote>:last-child{margin-bottom: 0}.markdown-body table{display: block;width: 100%;overflow: auto;word-break: normal;word-break: keep-all}.markdown-body table th{font-weight: bold}.markdown-body table th,.markdown-body table td{padding: 6px 13px;border: 1px solid #ddd}.markdown-body table tr{background-color: #fff;border-top: 1px solid #ccc}.markdown-body table tr:nth-child(2n){background-color: #f8f8f8}.markdown-body img{max-width: 100%;box-sizing: border-box}.markdown-body span.frame{display: block;overflow: hidden}.markdown-body span.frame>span{display: block;float: left;width: auto;padding: 7px;margin: 13px 0 0;overflow: hidden;border: 1px solid #ddd}.markdown-body span.frame span img{display: block;float: left}.markdown-body span.frame span span{display: block;padding: 5px 0 0;clear: both;color: #333}.markdown-body span.align-center{display: block;overflow: hidden;clear: both}.markdown-body span.align-center>span{display: block;margin: 13px auto 0;overflow: hidden;text-align: center}.markdown-body span.align-center span img{margin: 0 auto;text-align: center}.markdown-body span.align-right{display: block;overflow: hidden;clear: both}.markdown-body span.align-right>span{display: block;margin: 13px 0 0;overflow: hidden;text-align: right}.markdown-body span.align-right span img{margin: 0;text-align: right}.markdown-body span.float-left{display: block;float: left;margin-right: 13px;overflow: hidden}.markdown-body span.float-left span{margin: 13px 0 0}.markdown-body span.float-right{display: block;float: right;margin-left: 13px;overflow: hidden}.markdown-body span.float-right>span{display: block;margin: 13px auto 0;overflow: hidden;text-align: right}.markdown-body code,.markdown-body tt{padding: 0;padding-top: 0.2em;padding-bottom: 0.2em;margin: 0;font-size: 85%;background-color: rgba(0,0,0,0.04);border-radius: 3px}.markdown-body code:before,.markdown-body code:after,.markdown-body tt:before,.markdown-body tt:after{letter-spacing: -0.2em;content: "\00a0"}.markdown-body code br,.markdown-body tt br{display: none}.markdown-body del code{text-decoration: inherit}.markdown-body pre>code{padding: 0;margin: 0;font-size: 100%;word-break: normal;white-space: pre;background: transparent;border: 0}.markdown-body .highlight{margin-bottom: 16px}.markdown-body .highlight pre,.markdown-body pre{padding: 16px;overflow: auto;font-size: 85%;line-height: 1.45;background-color: #f7f7f7;border-radius: 3px}.markdown-body .highlight pre{margin-bottom: 0;word-break: normal}.markdown-body pre{word-wrap: normal}.markdown-body pre code,.markdown-body pre tt{display: inline;max-width: initial;padding: 0;margin: 0;overflow: initial;line-height: inherit;word-wrap: normal;background-color: transparent;border: 0}.markdown-body pre code:before,.markdown-body pre code:after,.markdown-body pre tt:before,.markdown-body pre tt:after{content: normal}.markdown-body kbd{display: inline-block;padding: 3px 5px;font-size: 11px;line-height: 10px;color: #555;vertical-align: middle;background-color: #fcfcfc;border: solid 1px #ccc;border-bottom-color: #bbb;border-radius: 3px;box-shadow: inset 0 -1px 0 #bbb}.codehilite{background: #ffffff}.codehilite .c{color: #999988;font-style: italic}.codehilite .err{color: #a61717;background-color: #e3d2d2}.codehilite .k{color: #000000;font-weight: bold}.codehilite .o{color: #000000;font-weight: bold}.codehilite .cm{color: #999988;font-style: italic}.codehilite .cp{color: #999999;font-weight: bold}.codehilite .c1{color: #999988;font-style: italic}.codehilite .cs{color: #999999;font-weight: bold;font-style: italic}.codehilite .gd{color: #000000;background-color: #ffdddd}.codehilite .gd .x{color: #000000;background-color: #ffaaaa}.codehilite .ge{color: #000000;font-style: italic}.codehilite .gr{color: #aa0000}.codehilite .gh{color: #999999}.codehilite .gi{color: #000000;background-color: #ddffdd}.codehilite .gi .x{color: #000000;background-color: #aaffaa}.codehilite .go{color: #888888}.codehilite .gp{color: #555555}.codehilite .gs{font-weight: bold}.codehilite .gu{color: #aaaaaa}.codehilite .gt{color: #aa0000}.codehilite .kc{color: #000000;font-weight: bold}.codehilite .kd{color: #000000;font-weight: bold}.codehilite .kp{color: #000000;font-weight: bold}.codehilite .kr{color: #000000;font-weight: bold}.codehilite .kt{color: #445588;font-weight: bold}.codehilite .m{color: #009999}.codehilite .s{color: #d14}.codehilite .na{color: #008080}.codehilite .nb{color: #0086B3}.codehilite .nc{color: #445588;font-weight: bold}.codehilite .no{color: #008080}.codehilite .ni{color: #800080}.codehilite .ne{color: #990000;font-weight: bold}.codehilite .nf{color: #990000;font-weight: bold}.codehilite .nn{color: #555555}.codehilite .nt{color: #000080}.codehilite .nv{color: #008080}.codehilite .ow{color: #000000;font-weight: bold}.codehilite .w{color: #bbbbbb}.codehilite .mf{color: #009999}.codehilite .mh{color: #009999}.codehilite .mi{color: #009999}.codehilite .mo{color: #009999}.codehilite .sb{color: #d14}.codehilite .sc{color: #d14}.codehilite .sd{color: #d14}.codehilite .s2{color: #d14}.codehilite .se{color: #d14}.codehilite .sh{color: #d14}.codehilite .si{color: #d14}.codehilite .sx{color: #d14}.codehilite .sr{color: #009926}.codehilite .s1{color: #d14}.codehilite .ss{color: #990073}.codehilite .bp{color: #999999}.codehilite .vc{color: #008080}.codehilite .vg{color: #008080}.codehilite .vi{color: #008080}.codehilite .il{color: #009999}
    </style>
    <style type="text/css">
      .markdown-body hr{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC")}
    </style>
  </head>
  <body>
    <div class="container">
      <div id="markup">
        <article id="content" class="markdown-body">
          <!-- MarkdownTOC -->

<ul>
<li><a href="#52-n-queens-ii-%E3%80%90%E5%9B%9E%E6%BA%AF%E6%B3%95%E3%80%91">52 N-Queens II 【回溯法】</a></li>
<li><a href="#53-maximum-subarray-%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91">53 Maximum Subarray 【动态规划】</a></li>
<li><a href="#54-spiral-matrix">54 Spiral Matrix</a></li>
<li><a href="#55-jump-game">55 Jump Game</a></li>
<li><a href="#56-merge-intervals-%E3%80%90%E6%80%9D%E8%B7%AF%EF%BC%8C%E7%B1%BB%E4%BC%BC%E6%B1%8224%E7%82%B9%EF%BC%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E6%A0%91%E3%80%91">56. Merge Intervals 【思路，类似求24点，运算符树】</a><ul>
<li><a href="#%E9%87%8D%E5%A4%8D%E5%80%BC%E7%9A%84set%E7%9A%84%E5%86%99%E6%B3%95">重复值的set的写法</a></li>
</ul>
</li>
<li><a href="#57-insert-interval-%E3%80%90%E8%B7%9F%E4%B8%8A%E9%A2%98%E6%80%9D%E8%B7%AF%E5%AE%8C%E5%85%A8%E7%B1%BB%E4%BC%BC%E3%80%91">57. Insert Interval 【跟上题思路完全类似】</a></li>
<li><a href="#58-length-of-last-word">58 Length of Last Word</a></li>
<li><a href="#61-rotate-list-%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91">61. Rotate List 【链表】</a></li>
<li><a href="#62-unique-paths">62. Unique Paths</a></li>
<li><a href="#63-unique-paths-ii">63. Unique Paths II</a></li>
<li><a href="#64-minimum-path-sum">64. Minimum Path Sum</a></li>
<li><a href="#66-plus-one">66. Plus One</a></li>
<li><a href="#69-sqrtx-%E3%80%90%E7%89%9B%E9%A1%BF%E9%80%BC%E8%BF%91%EF%BC%8C%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E9%87%8D%E8%A6%81%E3%80%91">69 Sqrt<mathjax>\(x\)</mathjax> 【牛顿逼近，数值计算重要】</a></li>
<li><a href="#72-edit-distance-%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91">72. Edit Distance 【动态规划】</a></li>
<li><a href="#75-sort-colors">75. Sort Colors</a></li>
<li><a href="#76-minimum-window-substring-%E3%80%90%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%A5%BD%E9%A2%98%E3%80%91">76. Minimum Window Substring 【字符串，好题】</a></li>
<li><a href="#77-combinations-%E3%80%90%E5%AE%9A%E9%95%BF%E5%AD%90%E9%9B%86%E7%94%9F%E6%88%90%E3%80%91">77. Combinations 【定长子集生成】</a></li>
<li><a href="#78-subsets--%E3%80%90%E5%AD%90%E9%9B%86%E7%94%9F%E6%88%90%E3%80%91">78. Subsets  【子集生成】</a></li>
<li><a href="#79-word-search-%E3%80%90%E6%90%9C%E7%B4%A2%E3%80%91">79. Word Search 【搜索】</a></li>
<li><a href="#80-remove-duplicates-from-sorted-array-ii-%E3%80%90%E5%8E%BB%E9%87%8D%E3%80%91">80. Remove Duplicates from Sorted Array II 【去重】</a></li>
<li><a href="#85-maximal-rectangle-%E3%80%90%E6%9F%A5%E6%89%BE%E3%80%91">85. Maximal Rectangle 【查找】</a></li>
<li><a href="#86-partition-list-%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91">86. Partition List 【链表】</a><ul>
<li><a href="#%E4%B8%8D%E8%83%BD%E7%BB%B4%E6%8C%81%E5%8E%9F%E5%A7%8B%E7%9B%B8%E5%AF%B9%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%86%99%E6%B3%95-%E3%80%90%E7%B1%BB%E4%BC%BC%E5%BF%AB%E6%8E%92%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E3%80%91">不能维持原始相对顺序的写法 【类似快排的处理方式】</a></li>
</ul>
</li>
<li><a href="#88-merge-sorted-array">88. Merge Sorted Array</a></li>
<li><a href="#89-gray-code-%E3%80%90%E5%A5%BD%E9%A2%98%E3%80%91">89. Gray Code 【好题】</a><ul>
<li><a href="#%E7%94%9F%E6%88%90%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2">生成码的字符串</a></li>
</ul>
</li>
<li><a href="#90-subsets-ii-%E3%80%90%E7%94%9F%E6%88%90%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E9%9B%86%E3%80%91">90. Subsets II 【生成不重复的子集】</a></li>
<li><a href="#93-restore-ip-addresses">93. Restore IP Addresses</a></li>
<li><a href="#94-binary-tree-inorder-traversal-%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E3%80%91">94. Binary Tree Inorder Traversal 【二叉树的非递归遍历】</a></li>
<li><a href="#95-unique-binary-search-trees-ii-%E3%80%90bst%E7%94%9F%E6%88%90%E3%80%91">95. Unique Binary Search Trees II 【BST生成】</a></li>
<li><a href="#96-unique-binary-search-trees-%E3%80%90bst%E6%95%B0%E9%87%8F%E3%80%91">96. Unique Binary Search Trees 【BST数量】</a></li>
<li><a href="#98-validate-binary-search-tree-%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91">98. Validate Binary Search Tree 【二叉树】</a></li>
<li><a href="#100-same-tree--%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91">100. Same Tree  【二叉树】</a></li>
</ul>
<!-- /MarkdownTOC -->

<div class="toc">
<ul>
<li><a href="#52-n-queens-ii">52 N-Queens II 【回溯法】</a></li>
<li><a href="#53-maximum-subarray">53 Maximum Subarray 【动态规划】</a></li>
<li><a href="#54-spiral-matrix">54 Spiral Matrix</a></li>
<li><a href="#55-jump-game">55 Jump Game</a></li>
<li><a href="#56-merge-intervals-24">56. Merge Intervals 【思路，类似求24点，运算符树】</a><ul>
<li><a href="#set">重复值的set的写法</a></li>
</ul>
</li>
<li><a href="#57-insert-interval">57. Insert Interval 【跟上题思路完全类似】</a></li>
<li><a href="#58-length-of-last-word">58 Length of Last Word</a></li>
<li><a href="#61-rotate-list">61. Rotate List 【链表】</a></li>
<li><a href="#62-unique-paths">62. Unique Paths</a></li>
<li><a href="#63-unique-paths-ii">63. Unique Paths II</a></li>
<li><a href="#64-minimum-path-sum">64. Minimum Path Sum</a></li>
<li><a href="#66-plus-one">66. Plus One</a></li>
<li><a href="#69-sqrtx">69 Sqrt(x) 【牛顿逼近，数值计算重要】</a></li>
<li><a href="#72-edit-distance">72. Edit Distance 【动态规划】</a></li>
<li><a href="#75-sort-colors">75. Sort Colors</a></li>
<li><a href="#76-minimum-window-substring">76. Minimum Window Substring 【字符串，好题】</a></li>
<li><a href="#77-combinations">77. Combinations 【定长子集生成】</a></li>
<li><a href="#78-subsets">78. Subsets  【子集生成】</a></li>
<li><a href="#79-word-search">79. Word Search 【搜索】</a></li>
<li><a href="#80-remove-duplicates-from-sorted-array-ii">80. Remove Duplicates from Sorted Array II 【去重】</a></li>
<li><a href="#85-maximal-rectangle">85. Maximal Rectangle 【查找】</a></li>
<li><a href="#86-partition-list">86. Partition List 【链表】</a><ul>
<li><a href="#_1">不能维持原始相对顺序的写法 【类似快排的处理方式】</a></li>
</ul>
</li>
<li><a href="#88-merge-sorted-array">88. Merge Sorted Array</a></li>
<li><a href="#89-gray-code">89. Gray Code 【好题】</a><ul>
<li><a href="#_2">生成码的字符串</a></li>
</ul>
</li>
<li><a href="#90-subsets-ii">90. Subsets II 【生成不重复的子集】</a></li>
<li><a href="#93-restore-ip-addresses">93. Restore IP Addresses</a></li>
<li><a href="#94-binary-tree-inorder-traversal">94. Binary Tree Inorder Traversal 【二叉树的非递归遍历】</a></li>
<li><a href="#95-unique-binary-search-trees-ii-bst">95. Unique Binary Search Trees II 【BST生成】</a></li>
<li><a href="#96-unique-binary-search-trees-bst">96. Unique Binary Search Trees 【BST数量】</a></li>
<li><a href="#98-validate-binary-search-tree">98. Validate Binary Search Tree 【二叉树】</a></li>
<li><a href="#100-same-tree">100. Same Tree  【二叉树】</a></li>
</ul>
</div>
<h1 id="52-n-queens-ii">52 N-Queens II 【回溯法】</h1>
<div class="codehilite"><pre>class Solution {
public:
    void solve(int cur, int n, vector&lt;int&gt; &amp;pos, vector&lt;int&gt; &amp;nag, vector&lt;int&gt; &amp;cols, int &amp; cnt)
    {
        if (cur == n)
        {
            cnt++;
            return;
        }
        for (int i = 0; i &lt; n; i++)
        {
            if (!cols[i] &amp;&amp; !pos[i + cur] &amp;&amp; !nag[i - cur + n - 1])
            {        
                nag[i - cur + n - 1] = cols[i] = pos[i + cur] = 1;
                solve(cur + 1, n, pos, nag, cols, cnt);
                nag[i - cur + n - 1] = cols[i] = pos[i + cur] = 0;
            }
        }
    }

    int totalNQueens(int n) {
        vector&lt;int&gt; posV(2 * n - 1,0);    //正向的对角线
        vector&lt;int&gt; nagV(2 * n - 1, 0);
        vector&lt;int&gt; cols(n, 0);            // 列
        int cnt=0;
        solve(0, n, posV, nagV, cols, cnt);
        return cnt;
    }
};
</pre></div>


<h1 id="53-maximum-subarray">53 Maximum Subarray 【动态规划】</h1>
<p><code>#define INT_MAX 0x7fffffff</code>
<code>#define INT_MIN 0x80000000</code>
<code>INT_MAX = 2147483647</code>
<code>INT_MIN = -2147483648</code></p>
<ul>
<li>注意<code>int</code>的最大最小值</li>
<li>记录以<code>i</code>结尾的最大值，如果前面的已经大于0，则可加上前面的，否则新开</li>
<li>遍历这个最大值集合即可得到最大值</li>
</ul>
<div class="codehilite"><pre>#define INT_MIN 0x80000000

class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int len = nums.size(); 
        vector&lt;int&gt; v(len);            // 记录以每个位置结尾的最大值
        v[0] = nums[0];
        for (int i = 1; i &lt; len; i++)
        {
            if (v[i - 1] &gt; 0)        // 如果前面的大于0，接上
                v[i] = v[i - 1] + nums[i];
            else
                v[i] = nums[i];
        }
        int sum = INT_MIN;            //注意边界
        for (int i = 0; i &lt; len; i++)
            if (v[i]&gt;sum)
                sum = v[i];
        return sum;
    }
};
</pre></div>


<h1 id="54-spiral-matrix">54 Spiral Matrix</h1>
<ul>
<li>按顺序访问四个方向</li>
<li>记录每个方向的边界值</li>
<li>用数组长度控制是否停止访问</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int l, r, u, d;
        vector&lt;int&gt; v;
        int len1 = matrix.size();
        if (len1 == 0)
            return v;
        int len2 = matrix[0].size();
        l = -1, r = len2, u = 0, d = len1;
        int i, j;
        i = j = 0;    
        int cnt = 0;
        while (true)
        {
            if (cnt &gt;= len1*len2)
                break;
            // 向右走
            while (true)
            {
                if (j &lt; r)
                {
                    v.push_back(matrix[i][j]);
                    cnt++;
                    j++;
                }            
                else
                {
                    j--;
                    r = j;
                    break;
                }
            }
            if (cnt &gt;= len1*len2)
                break;
            i++;        // 下移一个位置
            // 向下走
            while (true)
            {
                if (i &lt; d)
                {
                    v.push_back(matrix[i][j]);
                    cnt++;
                    i++;
                }
                else
                {
                    i--;
                    d = i;
                    break;
                }
            }
            if (cnt &gt;= len1*len2)
                break;
            j--;        // 左移一个位置
            // 向左走
            while (true)
            {
                if (j &gt; l)
                {
                    v.push_back(matrix[i][j]);
                    cnt++;
                    j--;
                }
                else
                {
                    j++;
                    l = j;
                    break;
                }
            }
            if (cnt &gt;= len1*len2)
                break;
            i--;    // 上移一个位置
            // 向上走
            while (true)
            {
                if (i &gt; u)
                {
                    v.push_back(matrix[i][j]);
                    cnt++;
                    i--;
                }
                else
                {
                    i++;
                    u = i;
                    break;
                }
            }
            j++;        //右移一个位置
        }
        return v;
    }

};
</pre></div>


<ul>
<li>java 解法 </li>
<li>使用一个数组来记录每个点是否被访问过，不需要记录上下左右四个位置</li>
<li>只需要判断是否超过数组边界，是否被访问过即可</li>
<li>循环结束由数组的个数控制</li>
<li>用数组来表示运动的方向</li>
</ul>
<div class="codehilite"><pre>class Solution {
    public List&lt;Integer&gt; spiralOrder(int[][] matrix) {
        List ans = new ArrayList();
        if (matrix.length == 0) return ans;
        int R = matrix.length, C = matrix[0].length;
        boolean[][] seen = new boolean[R][C];            // 用来记录是否被访问过
        int[] dr = {0, 1, 0, -1};            // 控制运动的方向
        int[] dc = {1, 0, -1, 0};
        int r = 0, c = 0, di = 0;
        for (int i = 0; i &lt; R * C; i++) {        // 控制运动的步数
            ans.add(matrix[r][c]);
            seen[r][c] = true;        //标记
            int cr = r + dr[di];        //下一步的位置
            int cc = c + dc[di];
            if (0 &lt;= cr &amp;&amp; cr &lt; R &amp;&amp; 0 &lt;= cc &amp;&amp; cc &lt; C &amp;&amp; !seen[cr][cc]){        //先判断是否越界，然后判断是否访问，防止访问数组越界
                r = cr;
                c = cc;
            } else {            // 该方向无法访问，换方向
                di = (di + 1) % 4;
                r += dr[di];
                c += dc[di];
            }
        }
        return ans;
    }
}
</pre></div>


<h1 id="55-jump-game">55 Jump Game</h1>
<ul>
<li>记录能到达的最右距离</li>
<li>如果某一个点无法到达，则后面都无法到达</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    bool canJump(vector&lt;int&gt;&amp; nums) {
        bool f = true;
        int r=0;
        r = max(r, nums[0]);
        for (int i = 1; i &lt; nums.size(); i++)
        {
            if (i &lt;= r)            // 只要有一个不可达，就无法到达
            {
                r = max(r, i+nums[i]);    //能到达的最右距离
            }
            else
            {
                f = false;
                break;
            }
        }
        return f;
    }
};
</pre></div>


<h1 id="56-merge-intervals-24">56. Merge Intervals 【思路，类似求24点，运算符树】</h1>
<ul>
<li>首先按照第一个值进行排序</li>
<li>每次比较两个，如果第一个值相同，比较第二个，删除较小的一个</li>
<li>如果第一个的第二个值大于第二个的第一个值，删除原来的两个，插入新的区间</li>
<li>注意使用允许重复值的<code>set</code>，先删除后插入，插入会使迭代器失效。</li>
</ul>
<div class="codehilite"><pre>/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) {
        auto f = [](const Interval &amp; a, const Interval &amp;b)-&gt;bool{return a.start &lt; b.start; };
        multiset&lt;Interval, bool(*)(const Interval &amp;, const Interval &amp;)&gt; s(f);
        vector&lt;Interval&gt; vi;
        for (const auto &amp;i : intervals)
            s.insert(i);
        while (s.size() &gt;= 2)
        {
            auto it1 = s.begin();
            auto it2 = s.begin();
            it2++;
            if (it1-&gt;start == it2-&gt;start)        // 两个初值相同的情况
            {            
                if (it1-&gt;end &gt;= it2-&gt;end)
                {
                    s.erase(it2);
                }
                else
                {
                    s.erase(it1);
                }
            }
            else if (it1-&gt;end &gt;= it2-&gt;start) // 有交集
            {
                Interval it(it1-&gt;start, max(it2-&gt;end,it1-&gt;end));
                s.erase(it1);
                s.erase(it2);
                s.insert(it);
            }
            else                 // 没有交集
            {
                vi.push_back(*it1);
                s.erase(it1);
            }
        }
        for (auto it = s.begin(); it != s.end(); ++it)
            vi.push_back(*it);
        return vi;
    }
};
</pre></div>


<h2 id="set">重复值的set的写法</h2>
<div class="codehilite"><pre>auto f = [](const Interval &amp; a, const Interval &amp;b)-&gt;bool{
if(a.start == b.start)
{
    return a.end&lt;b.end;
}
    return a.start&lt;b.start;
};
</pre></div>


<h1 id="57-insert-interval">57. Insert Interval 【跟上题思路完全类似】</h1>
<ul>
<li>使用栈不再使用<code>set</code></li>
</ul>
<div class="codehilite"><pre>/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) {
        stack&lt;Interval&gt; s;
        auto f = [](const Interval &amp; a, const Interval &amp;b)-&gt;bool{return a.start &lt; b.start; };
        intervals.push_back(newInterval);
        sort(intervals.begin(), intervals.end(), f);
        for (int i = intervals.size() - 1; i &gt;= 0; --i)
            s.push(intervals[i]);
        vector&lt;Interval&gt; vi;    
        while (s.size() &gt;= 2)
        {
            auto it1 = s.top();
            s.pop();
            auto it2 = s.top();    
            s.pop();
            if (it1.start == it2.start)        // 两个初值相同的情况
            {

                if (it1.end &gt;= it2.end)
                {
                    s.push(it1);
                }
                else
                {
                    s.push(it2);
                }
            }
            else if (it1.end &gt;= it2.start) // 有交集
            {
                Interval it(it1.start, max(it1.end,it2.end));
                s.push(it);
            }
            else                 // 没有交集
            {
                vi.push_back(it1);
                s.push(it2);
            }
        }
        while (!s.empty())
        {
            vi.push_back(s.top());
            s.pop();
        }
        return vi;
    }
};
</pre></div>


<h1 id="58-length-of-last-word">58 Length of Last Word</h1>
<ul>
<li>先去除多余的空格，多个空格只保留一个</li>
<li>注意判断末尾是空格的情况</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    int lengthOfLastWord(string s) {
        vector&lt;string&gt; v;

        string s1;
        int cnt = 0;
        // 去除多余的空格，只保留一个
        for (int i = 0; i &lt; s.size(); )
        {
            if (s[i] == &#39; &#39;)
            {
                s1 += s[i];
                i++;
                while (i &lt; s.size())
                {
                    if (s[i] != &#39; &#39;)
                        break;
                    i++;
                }
            }
            else
            {
                s1 += s[i];
                i++;
            }
        }
        s = s1;

        int last = 0;
        string str;
        for (int i = 0; i &lt; s.size(); i++)
        {
            if (s[i] == &#39; &#39;)
            {
                str = s.substr(last, i - last);
                last = i+1;
                v.push_back(str);
            }
        }
        // 最后一个
        str = s.substr(last, s.size() - last + 1);
        if(str.size()==0) // 如果是空，如果之前没有v，就加入，否则不加入
        {
            if(v.size()==0)
                v.push_back(str);
        }
        else
        {
            v.push_back(str);
        }

        /*for (int i = 0; i &lt; v.size(); i++)
            cout &lt;&lt; v[i] &lt;&lt; endl;*/
        return v[v.size() - 1].size();
    }
};
</pre></div>


<h1 id="61-rotate-list">61. Rotate List 【链表】</h1>
<blockquote>
<p>按位移动链表</p>
</blockquote>
<ul>
<li>考虑只有一个节点的情况</li>
<li>考虑k百分号后不一定的情况</li>
<li>以上的情况可能产生控节点</li>
</ul>
<div class="codehilite"><pre>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if (head == nullptr)
            return head;
        if (head-&gt;next == nullptr)      // 特殊情况1
            return head;
        int length = 1;
        ListNode * p = head;
        ListNode * p1 = head;
        ListNode * h;
        while (p-&gt;next)
        {
            length++;
            p = p-&gt;next;    // 现在p指向尾节点
        }
        k = k%length;        // %防止k超过长度
        if(k==0)        // 特殊情况2：如果不平移，经过下面的操作会使p1指向控节点
            return head;
        int step = length - k;
        while (--step)
        {
            p1 = p1-&gt;next;
        }
        h = p1-&gt;next;
        p1-&gt;next = nullptr;
        p-&gt;next = head;
        return h;
    }
};
</pre></div>


<h1 id="62-unique-paths">62. Unique Paths</h1>
<ul>
<li>从左上角走到右下角的路径数量</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    int uniquePaths(int m, int n) {
        vector&lt;vector&lt;int&gt; &gt; dp(m+1, vector&lt;int&gt;(n+1, 0));
        for (int i = 1; i &lt;= m; ++i)
        {
            for (int j = 1; j &lt;= n; ++j)
            {
                if (i == 1 &amp;&amp; j == 1)
                    dp[i][j] = 1;
                else
                {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }                
            }
        }
        return dp[m][n];
    }
};
</pre></div>


<h1 id="63-unique-paths-ii">63. Unique Paths II</h1>
<ul>
<li>类似上一题</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {
        vector&lt;vector&lt;int&gt;&gt; dp(obstacleGrid.size()+1, vector&lt;int&gt;(obstacleGrid[0].size()+1, 0));
        for (int i = 1; i &lt;= obstacleGrid.size(); ++i)
        {
            for (int j = 1; j &lt;= obstacleGrid[0].size(); ++j)
            {
                if (i == 1 &amp;&amp; j == 1)
                {
                    if (obstacleGrid[i - 1][j - 1] == 1)        // 第一个位置
                        dp[i][j] = 0;
                    else
                        dp[i][j] = 1;
                }
                else
                {
                    if (obstacleGrid[i-1][j-1] == 1)
                        dp[i][j] = INT_MIN;
                    else
                    {
                        if (dp[i - 1][j] == INT_MIN &amp;&amp;dp[i][j-1] == INT_MIN)
                            dp[i][j] =INT_MIN;
                        if (dp[i - 1][j] != INT_MIN)
                            dp[i][j] += dp[i - 1][j];
                        if (dp[i][j-1] != INT_MIN)
                            dp[i][j] += dp[i][j-1];
                    }
                }
            }
        }
        if(dp[obstacleGrid.size()][obstacleGrid[0].size()]==INT_MIN)    // 最后一个位置
            return 0;
        return dp[obstacleGrid.size()][obstacleGrid[0].size()];
    }
};
</pre></div>


<h1 id="64-minimum-path-sum">64. Minimum Path Sum</h1>
<div class="codehilite"><pre>class Solution {
public:
    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        for (int i = 1; i &lt; grid.size(); ++i)
            grid[i][0] += grid[i - 1][0];
        for (int i = 1; i &lt; grid[0].size();++i)
            grid[0][i] += grid[0][i - 1];

        for (int i = 1; i &lt; grid.size(); ++i)
        {
            for (int j = 1; j &lt; grid[0].size(); ++j)
            {
                grid[i][j] = min(grid[i][j - 1], grid[i - 1][j]) + grid[i][j];
            }
        }
        vector&lt;int&gt; v = grid[grid.size() - 1];
        return v[v.size() - 1];
    }
};
</pre></div>


<h1 id="66-plus-one">66. Plus One</h1>
<blockquote>
<p>对一个用数组表示的大数加一，高位在前面</p>
</blockquote>
<ul>
<li>只有对于全部是9的情况，才需要将第一位编程0，最后一位push一个0</li>
<li>其它的情况只要加到一个不是9的地方就可以返回了</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) {
        for (int i = digits.size() - 1; i &gt;= 0; i--)
        {
            if (digits[i] == 9)
                digits[i] = 0;
            else
            {
                digits[i]++;
                return digits;
            }
        }
        digits[0] = 1;
        digits.push_back(0);
        return digits;
    }
};
</pre></div>


<h1 id="69-sqrtx">69 Sqrt(x) 【牛顿逼近，数值计算重要】</h1>
<blockquote>
<p>求sqrt(x)</p>
</blockquote>
<ul>
<li>牛顿逼近<code>Xn+1 = Xn-f(n)/(f'(n))</code></li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    int mySqrt(int x) {
        long r = x; 
        while (r*r &gt; x)
            r = (r + x / r) / 2;
        return r;
    }
};
</pre></div>


<h1 id="72-edit-distance">72. Edit Distance 【动态规划】</h1>
<ul>
<li>编辑距离，三种，插入一个，删除一个，更改一个</li>
<li>动态规划求解</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    int solve(string word1, int idx1, string word2, int idx2, vector&lt;vector&lt;int&gt; &gt; &amp;dp)
    {    
        if (idx1 == word1.size() &amp;&amp; idx2 == word2.size())
            return 0;
        if (idx1 == word1.size())
        {
            return word2.size() - idx2;
        }
        if (idx2 == word2.size())
        {
            return word1.size() - idx1;
        }
        if (dp[idx1][idx2] != -1)
            return dp[idx1][idx2];
        if (word1[idx1] == word2[idx2])            // 相等，推进到下一个位置
        {
            dp[idx1][idx2] = solve(word1, idx1 + 1, word2, idx2 + 1, dp);
            return dp[idx1][idx2];
        }
        int cnt1 = solve(word1, idx1 + 1, word2, idx2,dp)+1;    // 删掉一个
        int cnt2 = solve(word1, idx1, word2, idx2 + 1,dp)+1;    // 插入一个
        int cnt3 = solve(word1, idx1 + 1, word2, idx2 + 1,dp)+1;    // 改正一个
        dp[idx1][idx2] = min(min(cnt1, cnt2), cnt3);
        return dp[idx1][idx2];
    }

    int minDistance(string word1, string word2) {
        vector&lt;vector&lt;int&gt; &gt; dp(word1.size(), vector&lt;int&gt;(word2.size(), -1));
        return solve(word1, 0, word2, 0,dp);
    }

};
</pre></div>


<h1 id="75-sort-colors">75. Sort Colors</h1>
<blockquote>
<p>对颜色排序</p>
</blockquote>
<ul>
<li>手写快速排序</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    int partition(vector&lt;int&gt; &amp;v, int start, int end)
    {
        int index = (start + end) / 2;    // 选定一个轴值
        swap(v[index], v[end]);        // 交换到结尾
        int cnt = start - 1;
        for (int id = start; id &lt; end; ++id)
        {
            if (v[id] &lt; v[end])
            {
                ++cnt;
                if (id!=cnt)
                    swap(v[id], v[cnt]);
            }
        }
        ++cnt;        // 切换到一个大于轴值的数
        swap(v[cnt], v[end]);
        return cnt;
    }

    void quickSort(vector&lt;int&gt; &amp;v, int start, int end)
    {
        if (start == end)
            return;
        int index = partition(v, start, end);
        if (index &gt; start)
            quickSort(v, start, index-1);
        if (index &lt; end)
            quickSort(v, index + 1, end);
    }


    void sortColors(vector&lt;int&gt;&amp; nums) {
        quickSort(nums, 0, nums.size() - 1);
    }
};
</pre></div>


<h1 id="76-minimum-window-substring">76. Minimum Window Substring 【字符串，好题】</h1>
<blockquote>
<p>母串S和子串T，找出包含子串T所有字符（记次数）的最短区间的母串</p>
</blockquote>
<ul>
<li>首先对子串进行哈希，求每个字符的次数，然后将每个放入集合，集合为空说明已经搜索完毕</li>
<li>给定两个搜索位置<code>start</code>和<code>end</code></li>
<li>如果未搜索完毕，则<code>end++</code>，然后更新<code>map</code>和<code>set</code></li>
<li>如果搜索完毕，首先查看是否是最小值；然后<code>start++</code>，更新<code>map</code>和<code>set</code></li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    string minWindow(string s, string t) {
           map&lt;char,int&gt; mps;
        set&lt;char&gt; scs,scsBack;
        for (int i = 0; i &lt; t.size(); ++i)
        {
            mps[t[i]]++;           
            scs.insert(t[i]);
            scsBack.insert(t[i]);
        }
        int minLength = INT_MAX;
        string minS;
        int start = 0, end = -1;
        int size = s.size();
        while (true)
        {
            if (scs.size() &gt; 0)    // 没有完全清除，end向后移动
            {
                if (end &gt;= size)
                    break;
                ++end;            
                if (scsBack.count(s[end]))        // 有用字符
                {
                    mps[s[end]]--;
                    if (mps[s[end]] &lt;= 0)
                    {
                        if (scs.count(s[end]))
                        {
                            scs.erase(s[end]);
                        }
                    }
                }            
            }
            else
            {
                if (end - start + 1 &lt; minLength)
                {
                    minLength = end - start + 1;
                    minS = s.substr(start, minLength);
                }
                if (scsBack.count(s[start]))        // 是所在字符串中的数字才有影响
                {
                    mps[s[start]]++;    
                    if (mps[s[start]] &gt; 0)
                    {
                        scs.insert(s[start]);
                    }
                }                        
                start++;
            }
        }
        return minS; 
    }
};
</pre></div>


<h1 id="77-combinations">77. Combinations 【定长子集生成】</h1>
<blockquote>
<p>给定n，k，在1~n的序列中，生成k长度的组合</p>
</blockquote>
<div class="codehilite"><pre>class Solution {
public:
    void solve(int idx, int n, vector&lt;int&gt; &amp;vi, vector&lt;vector&lt;int&gt; &gt; &amp;vvi,int k)
    {
        if (vi.size() == k)
        {        
            vvi.push_back(vi);
            return;
        }
        if (idx &gt; n)
        {
            return;
        }
        vi.push_back(idx);
        solve(idx + 1, n, vi, vvi, k);
        vi.pop_back();
        solve(idx + 1, n, vi, vvi, k);
    }

    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {
        vector&lt;vector&lt;int&gt; &gt; vvi;
        vector&lt;int&gt; vi;
        solve(1, n, vi, vvi,k);
        return vvi;
    }

};
</pre></div>


<h1 id="78-subsets">78. Subsets  【子集生成】</h1>
<ul>
<li>可以使用递归</li>
<li>也可以使用位操作，应该更快</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {
        int cnt = pow(2, nums.size());
        vector&lt;vector&lt;int&gt; &gt; vvi;
        for (int i = 0; i &lt; cnt; ++i)
        {
            vector&lt;int&gt; vi;
            for (int j = 0; j &lt; nums.size(); ++j)
            {
                int tmp = 0x01 &lt;&lt; j;
                if (tmp &amp; i)
                {
                    vi.push_back(nums[j]);
                }
            }
            vvi.push_back(vi);
        }
        return vvi;
    }
};
</pre></div>


<h1 id="79-word-search">79. Word Search 【搜索】</h1>
<ul>
<li>在矩阵中搜索单词，每个位置只能搜索一次，因此需要一个标记</li>
<li>找到与单词首字母相同的位置开始搜索</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    bool solve(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, int idx, vector&lt;vector&lt;bool&gt; &gt;&amp;f,int x,int y)
    {
        if (idx == word.size())
        {
            return true;
        }
        int direction[][2] = { -1, 0, 1, 0, 0, 1, 0, -1 };
        bool res = false;    
        for (int i = 0; i &lt; 4; ++i)
        {
            int dx = x + direction[i][0];
            int dy = y + direction[i][1];
            if (dx &gt;= 0 &amp;&amp; dx &lt; board.size() &amp;&amp; dy &gt;= 0 &amp;&amp; dy &lt; board[0].size())
            {
                if (f[dx][dy] == false &amp;&amp; board[dx][dy] == word[idx])
                {                
                    f[dx][dy] = true;
                    res = solve(board, word, idx + 1, f, dx, dy); 
                    if (res)
                        return true;                
                    f[dx][dy] = false;
                }
            }
        }
        return false;
    }

    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {
        for (int i = 0; i &lt; board.size(); ++i)
        {
            for (int j = 0; j &lt; board[0].size(); ++j)
            {
                if (board[i][j] == word[0])
                {
                    // 标记是否访问
                    vector&lt;vector&lt;bool&gt; &gt;f(board.size(), vector&lt;bool&gt;(board[0].size(), false));
                    f[i][j] = true;
                    if (solve(board, word, 1, f,i,j))    // 找到一个就返回
                    {
                        return true;
                    }
                }
            }
        }
        return false;
    }
};
</pre></div>


<h1 id="80-remove-duplicates-from-sorted-array-ii">80. Remove Duplicates from Sorted Array II 【去重】</h1>
<blockquote>
<p>去除数组中的超过两次的数字，只保留两次</p>
</blockquote>
<ul>
<li>使用变量分别记录上一次的数字和数量</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        if (nums.size() &lt;= 1)
            return nums.size();
        int cnt = 1;
        int last = nums[0];
        int currentCnt = 1;
        for (int i = 1; i &lt; nums.size(); ++i)
        {
            if (nums[i] != last)
            {
                last = nums[i];
                currentCnt = 1;
                nums[cnt++] = nums[i];
            }
            else
            {
                currentCnt++;
                if (currentCnt &lt;= 2)
                {
                    nums[cnt++] = nums[i];
                }
            }
        }
        return cnt;
    }
};
</pre></div>


<h1 id="85-maximal-rectangle">85. Maximal Rectangle 【查找】</h1>
<blockquote>
<p>在一个只有0 1的矩阵中查找最大的长方形</p>
</blockquote>
<ul>
<li>对于每个是<code>1</code>的位置，查找这个位置为起点的右下方的最大的矩阵</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    int solve(int x, int y, vector&lt;vector&lt;char&gt;&gt;&amp; matrix)
    {
        int max_v = 1;
        // 从每个位置向右下方查找
        for (int i = x; i &lt; matrix.size(); ++i)
        {
            if (matrix[i][y] == &#39;0&#39;)
                break;
            for (int j = y; j &lt; matrix[0].size(); ++j)
            {
                bool f = true;
                for (int k = x; k &lt;= i; ++k)    // 这一列每一个都要等于1
                {
                    if (matrix[k][j] == &#39;0&#39;)
                    {
                        f = false;
                        break;
                    }
                }
                if (!f)
                    break;
                max_v = max((i - x + 1)*(j - y + 1), max_v);
            }
        }
        return max_v;
    }

    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
        if(matrix.size()==0)
            return 0;
        int max_v = 0;
        for (int i = 0; i &lt; matrix.size(); ++i)
        {
            for (int j = 0; j &lt; matrix[0].size(); ++j)
            {
                if (matrix[i][j] == &#39;1&#39;)
                {
                    max_v = max(solve(i,j,matrix), max_v);
                }
            }
        }
        return max_v;
    }
};
</pre></div>


<h1 id="86-partition-list">86. Partition List 【链表】</h1>
<ul>
<li>类似快排的<code>partition</code></li>
<li>用两个链表存储，注意尾节点置空</li>
</ul>
<div class="codehilite"><pre>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        if (head == nullptr)
            return head;
        ListNode * tmp1 = new ListNode(1);
        ListNode * tmp2 = new ListNode(1);
        ListNode * h1 = tmp1, *h2 = tmp2;
        while (head)
        {
            if (head-&gt;val &lt; x)
            {
                tmp1-&gt;next = head;
                tmp1 = tmp1-&gt;next;
            }
            else
            {
                tmp2-&gt;next = head;
                tmp2 = tmp2-&gt;next;
            }
            head = head-&gt;next;
        }
        tmp1-&gt;next = tmp2-&gt;next = nullptr;
        if (h1-&gt;next != nullptr)
        {
            head = h1-&gt;next;
            while (h1-&gt;next)
            {
                h1 = h1-&gt;next;
            }
            h1-&gt;next = h2-&gt;next;
        }
        else
        {
            head = h2-&gt;next;
        }
        return head;
    }
};
</pre></div>


<h2 id="_1">不能维持原始相对顺序的写法 【类似快排的处理方式】</h2>
<div class="codehilite"><pre>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        if (head == nullptr)
            return head;
        ListNode * tmp1, *tmp2;
        tmp2 = tmp1 = head;
        while (tmp2)
        {
            if (tmp2-&gt;val &lt; x)
            {
                if (tmp1 != tmp2)
                {
                    int val = tmp2-&gt;val;
                    tmp2-&gt;val = tmp1-&gt;val;
                    tmp1-&gt;val = val;                    
                }
                tmp1 = tmp1-&gt;next;
            }
            tmp2 = tmp2-&gt;next;        
        }
        return head;
    }
};
</pre></div>


<h1 id="88-merge-sorted-array">88. Merge Sorted Array</h1>
<div class="codehilite"><pre>class Solution {
public:
    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
        vector&lt;int&gt; nums(m + n);
        int idx = 0;
        int idx1 = 0;
        int idx2 = 0;
        while (idx1 &lt; m &amp;&amp; idx2 &lt; n)
        {
            if (nums1[idx1] &lt; nums2[idx2])
            {
                nums[idx++] = nums1[idx1++];
            }
            else
            {
                nums[idx++] = nums2[idx2++];
            }
        }
        while (idx1 &lt; m)
        {
            nums[idx++] = nums1[idx1++];
        }
        while (idx2 &lt; n)
        {
            nums[idx++] = nums2[idx2++];
        }
        nums1 = nums;    }
};
</pre></div>


<h1 id="89-gray-code">89. Gray Code 【好题】</h1>
<div class="codehilite"><pre>class Solution {
public:
    vector&lt;int&gt; grayCode(int n) {
        vector&lt;int&gt; res(1, 0);
        for (int i = 0; i &lt; n; ++i) {
            int size = res.size();
            while (size--) {  // 上半部从下往上加，下半部从上往下加
                int curNum = res[size];
                curNum += (1 &lt;&lt; i);  // 首位加1
                res.push_back(curNum);
            }
        }
        return res;
    }
};
</pre></div>


<h2 id="_2">生成码的字符串</h2>
<div class="codehilite"><pre>vector&lt;int&gt; grayCode(int n) {
    unordered_set&lt;int&gt; s;
    vector&lt;int&gt; v;
    int cnt = pow(2, n);
    string str(n, &#39;0&#39;);    
    vector&lt;string&gt; f(cnt,str);
    str.pop_back();
    f[1] = str + &#39;1&#39;;
    for (int i = 2; i &lt;= n; ++i)
    {
        for (int j = pow(2, i-1); j &lt; pow(2, i); ++j)
        {
            int mid = 2.0*(pow(2, i - 1) - 0.5);
            f[j] = f[mid - j];        
            f[j][n - i] = &#39;1&#39;;
        }
    }
    return v;
}
</pre></div>


<h1 id="90-subsets-ii">90. Subsets II 【生成不重复的子集】</h1>
<div class="codehilite"><pre>class Solution {
public:
    void solve(map&lt;int, int&gt; &amp;mp, int idx, vector&lt;vector&lt;int&gt;&gt;&amp;vvi, vector&lt;int&gt; &amp;vi, vector&lt;int&gt;&amp; nums)
    {
        if (idx == nums.size())
        {
            vvi.push_back(vi);
            return;
        }
        for (int i = 0; i &lt;= mp[nums[idx]]; ++i)
        {
            for (int j = 0; j &lt; i; ++j)
                vi.push_back(nums[idx]);
            solve(mp, idx+1, vvi, vi, nums);
            for (int j = 0; j &lt; i; ++j)
                vi.pop_back();
        }    
    }

    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {
        map&lt;int,int&gt; mp;
        vector&lt;int&gt; numbers;
        for (const auto &amp;i : nums)
            mp[i]++;
        for (auto it = mp.begin(); it != mp.end(); ++it)
            numbers.push_back(it-&gt;first);
        vector&lt;vector&lt;int&gt; &gt; vvi;
        vector&lt;int&gt; vi;
        solve(mp, 0, vvi, vi, numbers);
        return vvi;
    }
};
</pre></div>


<h1 id="93-restore-ip-addresses">93. Restore IP Addresses</h1>
<blockquote>
<p>解析ip地址</p>
</blockquote>
<ul>
<li>注意0开头的数字</li>
<li>限制层数</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    void solve(string s, int idx, vector&lt;string&gt; &amp; vs,vector&lt;string&gt; &amp;ds)
    {
        if (idx == s.size())
        {
            if (ds.size() == 4)
            {
                string str;
                str = ds[0] + &quot;.&quot; + ds[1] + &quot;.&quot; + ds[2] + &quot;.&quot; + ds[3];
                vs.push_back(str);
            }
            return;
        }
        // 限制层数
        if(ds.size()&gt;4)
            return;
        for (int i = idx; i &lt; min(idx + 3, (int)s.size()); ++i)
        {
            string subs = s.substr(idx, i - idx + 1);
            int tmp;
            sscanf(subs.c_str(), &quot;%d&quot;, &amp;tmp);
            if ( i - idx!=0 &amp;&amp; tmp&lt;pow(10, i - idx))       // 排除0开头的特殊情况
                continue;
            if (tmp &gt;= 0 &amp;&amp; tmp &lt;= 255)
            {
                ds.push_back(subs);
                solve(s, i + 1, vs, ds);
                ds.pop_back();
            }
        }
    }

    vector&lt;string&gt; restoreIpAddresses(string s) {
        vector&lt;string&gt; vs;
        vector&lt;string&gt; ds;
        solve(s, 0, vs,ds);
        return vs;
    }
};

/*&quot;0000&quot;
&quot;25525511135&quot;
&quot;010010&quot;
*/
</pre></div>


<h1 id="94-binary-tree-inorder-traversal">94. Binary Tree Inorder Traversal 【二叉树的非递归遍历】</h1>
<p>＞　二叉树非递归遍历</p>
<ul>
<li>使用一个标志标记进栈次数</li>
<li>二次进栈才遍历</li>
</ul>
<div class="codehilite"><pre>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; v;
        if (root == nullptr)
            return v;
        stack&lt;pair&lt;TreeNode *,bool&gt;&gt; st;
        st.push(make_pair(root, false));
        while (!st.empty())
        {
            auto tmp = st.top();
            auto f = tmp.second;
            st.pop();
            if (f)
            {
                v.push_back(tmp.first-&gt;val);
            }
            else
            {
            //遍历逻辑写在这
                if (tmp.first-&gt;right)
                    st.push(make_pair(tmp.first-&gt;right, false));
                st.push(make_pair(tmp.first, true));
                if (tmp.first-&gt;left)
                    st.push(make_pair(tmp.first-&gt;left, false));
            }
        }
        return v;
    }
};
</pre></div>


<h1 id="95-unique-binary-search-trees-ii-bst">95. Unique Binary Search Trees II 【BST生成】</h1>
<blockquote>
<p>给定一个序列，求BST的类数，并求取所有的形状</p>
</blockquote>
<ul>
<li>递归操作，选择一个作为根节点，分别递归到左半边和右半边。交叉相乘，类似下一题的求数量的过程。</li>
<li>注意0的边界条件</li>
</ul>
<div class="codehilite"><pre>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;TreeNode*&gt; solve(int start, int end)
    {
        vector&lt;TreeNode *&gt; res;
        if (start &gt; end)
        {
            res.push_back(nullptr);
            return res;
        }
        for (int k = start; k &lt;= end; ++k)
        {
            vector&lt;TreeNode *&gt;left, right;        
            left = solve(start, k - 1);
            right = solve(k + 1, end);        
            for (int i = 0; i &lt; left.size(); ++i)
            {
                for (int j = 0; j &lt; right.size(); ++j)
                {
                    TreeNode * tmp = new TreeNode(k);    // 根节点
                    tmp-&gt;left = left[i];
                    tmp-&gt;right = right[j];
                    res.push_back(tmp);
                }
            }
        }
        return res;
    }

    vector&lt;TreeNode*&gt; generateTrees(int n) {    
        vector&lt;TreeNode*&gt; vt;
        if(n==0)
            return vt;
        return solve(1, n);
    }
};
</pre></div>


<h1 id="96-unique-binary-search-trees-bst">96. Unique Binary Search Trees 【BST数量】</h1>
<blockquote>
<p>给定一个序列，求BST的类数</p>
</blockquote>
<ul>
<li>分拆成子问题，一个长度为i的bst序列，如果选取第j个为根节点，子问题是idx[j]和idx[i-j-1]，总数是这两个子问题的组合数。</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    int numTrees(int n) {
        if(n&lt;0)
            return -1;
        int * idx = new int[n+1];
        memset(idx,0,sizeof(int)*(n+1));
        idx[0]=1;
        idx[1]=1;
        for(int i=2;i&lt;=n;i++){
            for(int j=0;j&lt;i;j++){
                idx[i]+=idx[j]*idx[i-j-1];
            }
        }
        return idx[n];
    }
};
</pre></div>


<h1 id="98-validate-binary-search-tree">98. Validate Binary Search Tree 【二叉树】</h1>
<blockquote>
<p>判断一棵树是不是bst</p>
</blockquote>
<ul>
<li>中序遍历看是否是递增的</li>
<li>其实是由bug的，对于相等的数字，位于左右节点有时候得到的中序遍历序列是一样的</li>
</ul>
<div class="codehilite"><pre>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void travel(TreeNode * root, vector&lt;int&gt; &amp;v)
    {
        if (root)
        {
            travel(root-&gt;left, v);
            v.push_back(root-&gt;val);
            travel(root-&gt;right, v);
        }
    }

    bool isValidBST(TreeNode* root) {
        if (root == nullptr)
            return true;
        //return solve(root, root-&gt;val, root-&gt;val);
        vector&lt;int&gt; v;
        travel(root, v);
        for (int i = 1; i &lt; v.size(); ++i)
            if (v[i] &lt;= v[i - 1])
                return false;
        return true;
    }
};
</pre></div>


<h1 id="100-same-tree">100. Same Tree  【二叉树】</h1>
<div class="codehilite"><pre>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (p == nullptr &amp;&amp; q == nullptr)
            return true;
        if (p != nullptr &amp;&amp; q != nullptr)
        {
            if (p-&gt;val == q-&gt;val)
                return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);
        }
        return false;
    }
};
</pre></div>
        </article>
      </div>
    </div>
  </body>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$', '$$'], ["\\[", "\\]"] ],
          processEscapes: true
        },
        TeX: {
          equationNumbers: {
            autoNumber: 'AMS'
          }
        },
        "HTML-CSS": {
          imageFont: null
        }
      });
  </script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/2.1-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</html>
