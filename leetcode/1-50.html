<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>1-50.md—F:\e\算法\leetcode刷题记录</title>
    <style type="text/css">
    html{font-family: sans-serif;-ms-text-size-adjust: 100%;-webkit-text-size-adjust: 100%}body{margin: 0}article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display: block}audio,canvas,progress,video{display: inline-block;vertical-align: baseline}audio:not([controls]){display: none;height: 0}[hidden],template{display: none}a{background: transparent}a:active,a:hover{outline: 0}abbr[title]{border-bottom: 1px dotted}b,strong{font-weight: bold}dfn{font-style: italic}h1{font-size: 2em;margin: 0.67em 0}mark{background: #ff0;color: #000}small{font-size: 80%}sub,sup{font-size: 75%;line-height: 0;position: relative;vertical-align: baseline}sup{top: -0.5em}sub{bottom: -0.25em}img{border: 0}svg:not(:root){overflow: hidden}figure{margin: 1em 40px}hr{box-sizing: content-box;height: 0}pre{overflow: auto}code,kbd,pre,samp{font-family: monospace, monospace;font-size: 1em}button,input,optgroup,select,textarea{color: inherit;font: inherit;margin: 0}button{overflow: visible}button,select{text-transform: none}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance: button;cursor: pointer}button[disabled],html input[disabled]{cursor: default}button::-moz-focus-inner,input::-moz-focus-inner{border: 0;padding: 0}input{line-height: normal}input[type="checkbox"],input[type="radio"]{box-sizing: border-box;padding: 0}input[type="number"]::-webkit-inner-spin-button,input[type="number"]::-webkit-outer-spin-button{height: auto}input[type="search"]{-webkit-appearance: textfield;box-sizing: content-box}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance: none}fieldset{border: 1px solid #c0c0c0;margin: 0 2px;padding: 0.35em 0.625em 0.75em}legend{border: 0;padding: 0}textarea{overflow: auto}optgroup{font-weight: bold}table{border-collapse: collapse;border-spacing: 0}td,th{padding: 0}*{box-sizing: border-box}input,select,textarea,button{font: 13px/1.4 Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"}body{min-width: 1020px;font: 13px/1.4 Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";color: #333;background-color: #fff}a{color: #4183c4;text-decoration: none}a:hover,a:active{text-decoration: underline}hr,.rule{height: 0;margin: 15px 0;overflow: hidden;background: transparent;border: 0;border-bottom: 1px solid #ddd}hr:before,.rule:before{display: table;content: ""}hr:after,.rule:after{display: table;clear: both;content: ""}h1,h2,h3,h4,h5,h6{margin-top: 15px;margin-bottom: 15px;line-height: 1.1}h1{font-size: 30px}h2{font-size: 21px}h3{font-size: 16px}h4{font-size: 14px}h5{font-size: 12px}h6{font-size: 11px}small{font-size: 90%}blockquote{margin: 0}.lead{margin-bottom: 30px;font-size: 20px;font-weight: 300;color: #555}.text-muted{color: #999}.text-danger{color: #bd2c00}.text-emphasized{font-weight: bold;color: #333}ul,ol{padding: 0;margin-top: 0;margin-bottom: 0}ol ol,ul ol{list-style-type: lower-roman}ul ul ol,ul ol ol,ol ul ol,ol ol ol{list-style-type: lower-alpha}dd{margin-left: 0}tt,code{font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;font-size: 12px}pre{margin-top: 0;margin-bottom: 0;font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace}#realtime .status{overflow: visible;position: absolute;top: -5px;left: 0;background: url("/public/images/github-status.png");width: 26px;height: 26px;display: block;margin: 0 5px 0 0}#realtime .up{background-position: 0 0}#realtime .problem{background-position: 0 -53px}#realtime .down{background-position: 0 -26px}.container{max-width: 920px;margin: 0 auto 20px auto}#header{background: #FAFAFA;background: -moz-linear-gradient(#FAFAFA, #EAEAEA);background: -webkit-linear-gradient(#FAFAFA, #EAEAEA);-ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr='#fafafa', endColorstr='#eaeaea')";border-bottom: 1px solid #CACACA;box-shadow: 0 1px 0 rgba(255, 255, 255, 0.4),0 0 10px rgba(0, 0, 0, 0.1)}#markup{padding: 3px}#markup article{padding-top: 30px}.markdown-body{overflow: hidden;font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;font-size: 16px;line-height: 1.6;word-wrap: break-word}.markdown-body>*:first-child{margin-top: 0 !important}.markdown-body>*:last-child{margin-bottom: 0 !important}.markdown-body .absent{color: #c00}.markdown-body .anchor{position: absolute;top: 0;left: 0;display: block;padding-right: 6px;padding-left: 30px;margin-left: -30px}.markdown-body .anchor:focus{outline: none}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{position: relative;margin-top: 1em;margin-bottom: 16px;font-weight: bold;line-height: 1.4}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{display: none;color: #000;vertical-align: middle}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{padding-left: 8px;margin-left: -30px;text-decoration: none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{display: inline-block}.markdown-body h1 tt,.markdown-body h1 code,.markdown-body h2 tt,.markdown-body h2 code,.markdown-body h3 tt,.markdown-body h3 code,.markdown-body h4 tt,.markdown-body h4 code,.markdown-body h5 tt,.markdown-body h5 code,.markdown-body h6 tt,.markdown-body h6 code{font-size: inherit}.markdown-body h1{padding-bottom: 0.3em;font-size: 2.25em;line-height: 1.2;border-bottom: 1px solid #eee}.markdown-body h1 .anchor{line-height: 1}.markdown-body h2{padding-bottom: 0.3em;font-size: 1.75em;line-height: 1.225;border-bottom: 1px solid #eee}.markdown-body h2 .anchor{line-height: 1}.markdown-body h3{font-size: 1.5em;line-height: 1.43}.markdown-body h3 .anchor{line-height: 1.2}.markdown-body h4{font-size: 1.25em}.markdown-body h4 .anchor{line-height: 1.2}.markdown-body h5{font-size: 1em}.markdown-body h5 .anchor{line-height: 1.1}.markdown-body h6{font-size: 1em;color: #777}.markdown-body h6 .anchor{line-height: 1.1}.markdown-body p,.markdown-body blockquote,.markdown-body ul,.markdown-body ol,.markdown-body dl,.markdown-body table,.markdown-body pre{margin-top: 0;margin-bottom: 16px}.markdown-body hr{height: 4px;padding: 0;margin: 16px 0;background-color: #e7e7e7;border: 0 none}.markdown-body ul,.markdown-body ol{padding-left: 2em}.markdown-body ul.no-list,.markdown-body ol.no-list{padding: 0;list-style-type: none}.markdown-body ul ul,.markdown-body ul ol,.markdown-body ol ol,.markdown-body ol ul{margin-top: 0;margin-bottom: 0}.markdown-body li>p{margin-top: 16px}.markdown-body dl{padding: 0}.markdown-body dl dt{padding: 0;margin-top: 16px;font-size: 1em;font-style: italic;font-weight: bold}.markdown-body dl dd{padding: 0 16px;margin-bottom: 16px}.markdown-body blockquote{padding: 0 15px;color: #777;border-left: 4px solid #ddd}.markdown-body blockquote>:first-child{margin-top: 0}.markdown-body blockquote>:last-child{margin-bottom: 0}.markdown-body table{display: block;width: 100%;overflow: auto;word-break: normal;word-break: keep-all}.markdown-body table th{font-weight: bold}.markdown-body table th,.markdown-body table td{padding: 6px 13px;border: 1px solid #ddd}.markdown-body table tr{background-color: #fff;border-top: 1px solid #ccc}.markdown-body table tr:nth-child(2n){background-color: #f8f8f8}.markdown-body img{max-width: 100%;box-sizing: border-box}.markdown-body span.frame{display: block;overflow: hidden}.markdown-body span.frame>span{display: block;float: left;width: auto;padding: 7px;margin: 13px 0 0;overflow: hidden;border: 1px solid #ddd}.markdown-body span.frame span img{display: block;float: left}.markdown-body span.frame span span{display: block;padding: 5px 0 0;clear: both;color: #333}.markdown-body span.align-center{display: block;overflow: hidden;clear: both}.markdown-body span.align-center>span{display: block;margin: 13px auto 0;overflow: hidden;text-align: center}.markdown-body span.align-center span img{margin: 0 auto;text-align: center}.markdown-body span.align-right{display: block;overflow: hidden;clear: both}.markdown-body span.align-right>span{display: block;margin: 13px 0 0;overflow: hidden;text-align: right}.markdown-body span.align-right span img{margin: 0;text-align: right}.markdown-body span.float-left{display: block;float: left;margin-right: 13px;overflow: hidden}.markdown-body span.float-left span{margin: 13px 0 0}.markdown-body span.float-right{display: block;float: right;margin-left: 13px;overflow: hidden}.markdown-body span.float-right>span{display: block;margin: 13px auto 0;overflow: hidden;text-align: right}.markdown-body code,.markdown-body tt{padding: 0;padding-top: 0.2em;padding-bottom: 0.2em;margin: 0;font-size: 85%;background-color: rgba(0,0,0,0.04);border-radius: 3px}.markdown-body code:before,.markdown-body code:after,.markdown-body tt:before,.markdown-body tt:after{letter-spacing: -0.2em;content: "\00a0"}.markdown-body code br,.markdown-body tt br{display: none}.markdown-body del code{text-decoration: inherit}.markdown-body pre>code{padding: 0;margin: 0;font-size: 100%;word-break: normal;white-space: pre;background: transparent;border: 0}.markdown-body .highlight{margin-bottom: 16px}.markdown-body .highlight pre,.markdown-body pre{padding: 16px;overflow: auto;font-size: 85%;line-height: 1.45;background-color: #f7f7f7;border-radius: 3px}.markdown-body .highlight pre{margin-bottom: 0;word-break: normal}.markdown-body pre{word-wrap: normal}.markdown-body pre code,.markdown-body pre tt{display: inline;max-width: initial;padding: 0;margin: 0;overflow: initial;line-height: inherit;word-wrap: normal;background-color: transparent;border: 0}.markdown-body pre code:before,.markdown-body pre code:after,.markdown-body pre tt:before,.markdown-body pre tt:after{content: normal}.markdown-body kbd{display: inline-block;padding: 3px 5px;font-size: 11px;line-height: 10px;color: #555;vertical-align: middle;background-color: #fcfcfc;border: solid 1px #ccc;border-bottom-color: #bbb;border-radius: 3px;box-shadow: inset 0 -1px 0 #bbb}.codehilite{background: #ffffff}.codehilite .c{color: #999988;font-style: italic}.codehilite .err{color: #a61717;background-color: #e3d2d2}.codehilite .k{color: #000000;font-weight: bold}.codehilite .o{color: #000000;font-weight: bold}.codehilite .cm{color: #999988;font-style: italic}.codehilite .cp{color: #999999;font-weight: bold}.codehilite .c1{color: #999988;font-style: italic}.codehilite .cs{color: #999999;font-weight: bold;font-style: italic}.codehilite .gd{color: #000000;background-color: #ffdddd}.codehilite .gd .x{color: #000000;background-color: #ffaaaa}.codehilite .ge{color: #000000;font-style: italic}.codehilite .gr{color: #aa0000}.codehilite .gh{color: #999999}.codehilite .gi{color: #000000;background-color: #ddffdd}.codehilite .gi .x{color: #000000;background-color: #aaffaa}.codehilite .go{color: #888888}.codehilite .gp{color: #555555}.codehilite .gs{font-weight: bold}.codehilite .gu{color: #aaaaaa}.codehilite .gt{color: #aa0000}.codehilite .kc{color: #000000;font-weight: bold}.codehilite .kd{color: #000000;font-weight: bold}.codehilite .kp{color: #000000;font-weight: bold}.codehilite .kr{color: #000000;font-weight: bold}.codehilite .kt{color: #445588;font-weight: bold}.codehilite .m{color: #009999}.codehilite .s{color: #d14}.codehilite .na{color: #008080}.codehilite .nb{color: #0086B3}.codehilite .nc{color: #445588;font-weight: bold}.codehilite .no{color: #008080}.codehilite .ni{color: #800080}.codehilite .ne{color: #990000;font-weight: bold}.codehilite .nf{color: #990000;font-weight: bold}.codehilite .nn{color: #555555}.codehilite .nt{color: #000080}.codehilite .nv{color: #008080}.codehilite .ow{color: #000000;font-weight: bold}.codehilite .w{color: #bbbbbb}.codehilite .mf{color: #009999}.codehilite .mh{color: #009999}.codehilite .mi{color: #009999}.codehilite .mo{color: #009999}.codehilite .sb{color: #d14}.codehilite .sc{color: #d14}.codehilite .sd{color: #d14}.codehilite .s2{color: #d14}.codehilite .se{color: #d14}.codehilite .sh{color: #d14}.codehilite .si{color: #d14}.codehilite .sx{color: #d14}.codehilite .sr{color: #009926}.codehilite .s1{color: #d14}.codehilite .ss{color: #990073}.codehilite .bp{color: #999999}.codehilite .vc{color: #008080}.codehilite .vg{color: #008080}.codehilite .vi{color: #008080}.codehilite .il{color: #009999}
    </style>
    <style type="text/css">
      .markdown-body hr{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC")}
    </style>
  </head>
  <body>
    <div class="container">
      <div id="markup">
        <article id="content" class="markdown-body">
          <div class="toc">
<ul>
<li><a href="#1-two-sum">1 Two Sum 【哈希】</a></li>
<li><a href="#2-add-two-numbers">2 Add Two Numbers 【链表】</a></li>
<li><a href="#3-longest-substring-without-repeating-characters">3 Longest Substring Without Repeating Characters 【类动态规划】</a></li>
<li><a href="#4-median-of-two-sorted-arrays">4 Median of Two Sorted Arrays  【！重要的思路！】</a></li>
<li><a href="#5-longest-palindromic-substring">5 Longest Palindromic Substring</a></li>
<li><a href="#6-zigzag-conversion">6 ZigZag Conversion</a></li>
<li><a href="#7-reverse-integer">7 Reverse Integer</a></li>
<li><a href="#8-string-to-integer-atoi">8 String to Integer (atoi) 【细节多】</a></li>
<li><a href="#9-palindrome-number">9 Palindrome Number 【考虑溢出】</a></li>
<li><a href="#10-regular-expression-matching">10 Regular Expression Matching 【动态规划】</a><ul>
<li><a href="#_1">自己的解法</a></li>
<li><a href="#_2">别人的解法一  回溯，递归调用</a></li>
<li><a href="#_3">别人的解法二 动态规划，使用数组</a></li>
</ul>
</li>
<li><a href="#11-container-with-most-water">11 Container With Most Water</a></li>
<li><a href="#12-integer-to-roman">12 Integer to Roman</a></li>
<li><a href="#13-roman-to-integer">13 Roman to Integer</a></li>
<li><a href="#14-longest-common-prefix">14 Longest Common Prefix</a></li>
<li><a href="#15-3sum">15 3sum</a></li>
<li><a href="#16-3sum-closest">16 3Sum Closest</a></li>
<li><a href="#17-letter-combinations-of-a-phone-number">17 Letter Combinations of a Phone Number</a><ul>
<li><a href="#_4">解法一</a></li>
<li><a href="#_5">解法二 循环</a></li>
</ul>
</li>
<li><a href="#18-4sum">18 4sum</a></li>
<li><a href="#19-remove-nth-node-from-end-of-list">19 Remove Nth Node From End of List 【链表】</a></li>
<li><a href="#20-valid-parentheses">20 Valid Parentheses 【栈】</a></li>
<li><a href="#21-merge-two-sorted-lists">21 Merge Two Sorted Lists 【链表】</a></li>
<li><a href="#22-generate-parentheses">22 Generate Parentheses 【回溯法搜索】</a></li>
<li><a href="#23-merge-k-sorted-lists">23 Merge k Sorted Lists</a></li>
<li><a href="#24-swap-nodes-in-pairs">24 Swap Nodes in Pairs 【链表】</a></li>
<li><a href="#25-reverse-nodes-in-k-group">25 Reverse Nodes in k-Group 【链表】</a><ul>
<li><a href="#_6">翻转单链表的三种方法 【重要】</a></li>
</ul>
</li>
<li><a href="#26-remove-duplicates-from-sorted-array">26 Remove Duplicates from Sorted Array【线性空间删除数组重复值】</a></li>
<li><a href="#27-remove-element">27 Remove Element</a></li>
<li><a href="#28-implement-strstr">28 Implement strStr()</a></li>
<li><a href="#29-divide-two-integers">29 Divide Two Integers 【数值计算，重要】</a><ul>
<li><a href="#_7">自己的代码，不知道为啥没通过</a></li>
<li><a href="#_8">别人的代码通过</a></li>
<li><a href="#_9">递归写法</a></li>
</ul>
</li>
<li><a href="#34-search-for-a-range">34 Search for a Range 【二分法】</a></li>
<li><a href="#35-search-insert-position">35 Search Insert Position 【二分法】</a></li>
<li><a href="#36-valid-sudoku">36 Valid Sudoku</a></li>
<li><a href="#37-sudoku-solver">37 Sudoku Solver 【九宫格算法】</a></li>
<li><a href="#42-trapping-rain-water">42 Trapping Rain Water</a></li>
<li><a href="#45-jump-game-ii">45 Jump Game II</a></li>
<li><a href="#46-permutations">46 Permutations 【搜索】</a></li>
<li><a href="#47-permutations-ii">47 Permutations II 【同样的题目，只是数字可能会重复，代码是相同】</a></li>
<li><a href="#48-rotate-image">48 Rotate Image 【矩阵操作】</a><ul>
<li><a href="#_10">方法一</a></li>
<li><a href="#_11">方法二</a></li>
<li><a href="#_12">方法三</a></li>
</ul>
</li>
<li><a href="#49-group-anagrams">49 Group Anagrams 【哈希】</a></li>
<li><a href="#50-powxn">50 Pow(x,n) 【分治法，数值计算重要】</a></li>
</ul>
</div>
<h1 id="1-two-sum">1 Two Sum 【哈希】</h1>
<ul>
<li>先排序</li>
<li>然后从两端开始寻找</li>
<li>然后找到在原数组中的索引</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;int&gt; snums = nums;
// 先排序
        sort(nums.begin(), nums.end());
        int len = nums.size();
        int l = 0;
        int r = len-1;
// 然后从两端开始往中间寻找
        while (l &lt; r)
        {
            if (nums[l] + nums[r]&gt;target)
                r--;
            else if (nums[l] + nums[r] &lt; target)
                l++;
            else
                break;
        }
        vector&lt;int&gt; f(len, 0);
        vector&lt;int&gt; v;
// 然后找到在原数组的索引
        for (int i = 0; i &lt; len; i++)
        {
            if (nums[l] == snums[i] &amp;&amp; !f[i])
            {
                f[i] = 1;
                v.push_back(i);
                break;
            }
        }
        for (int i = 0; i &lt; len; i++)
        {
            if (nums[r] == snums[i] &amp;&amp; !f[i])
            {
                f[i] = 1;
                v.push_back(i);
            }
        }
        return v;
    }
};
</pre></div>


<ul>
<li>使用哈希表的思路</li>
<li>先建立每个数的哈希表</li>
<li>遍历每一个数，得到<code>sum-a</code>的值</li>
<li>然后再哈希表中查找是否有该值</li>
</ul>
<div class="codehilite"><pre>public int[] twoSum(int[] nums, int target) {
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    for (int i = 0; i &lt; nums.length; i++) {
        map.put(nums[i], i);
    }
    for (int i = 0; i &lt; nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) {
            return new int[] { i, map.get(complement) };
        }
    }
    throw new IllegalArgumentException(&quot;No two sum solution&quot;);
}
</pre></div>


<ul>
<li>更快速的代码</li>
<li>只需要遍历一遍</li>
</ul>
<div class="codehilite"><pre>public int[] twoSum(int[] nums, int target) {
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    for (int i = 0; i &lt; nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[] { map.get(complement), i };
        }
        map.put(nums[i], i);
    }
    throw new IllegalArgumentException(&quot;No two sum solution&quot;);
}
</pre></div>


<h1 id="2-add-two-numbers">2 Add Two Numbers 【链表】</h1>
<ul>
<li>使用一个固定的表头，最后去掉，降低编程复杂性</li>
<li>最后一个进位记住要检查一下</li>
</ul>
<div class="codehilite"><pre>/**
* Definition for singly-linked list.
* struct ListNode {
*    int val;
*    ListNode *next;
*    ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode * h1, *h2;
        h1 = l1;
        h2 = l2;
        // 先用一个非空的表头，降低编程复杂性
        ListNode * h = new ListNode(0);
        ListNode *p = h;
        int r = 0,val;
        while (true)
        {
            // 两个都有
            while (h1 != NULL &amp;&amp; h2 != NULL)
            {
                val = h1-&gt;val + h2-&gt;val + r;
                r = val / 10;
                val = val % 10;
                ListNode * tmp = new ListNode(val);
                p-&gt;next = tmp;
                p = p-&gt;next;
                h1 = h1-&gt;next;
                h2 = h2-&gt;next;
            }
            while (h1 != NULL)
            {
                val = h1-&gt;val + r;
                r = val / 10;
                val = val % 10;
                ListNode * tmp = new ListNode(val);
                p-&gt;next = tmp;
                p = p-&gt;next;
                h1 = h1-&gt;next;
            }
            while (h2 != NULL)
            {
                val = h2-&gt;val + r;
                r = val / 10;
                val = val % 10;
                ListNode * tmp = new ListNode(val);
                p-&gt;next = tmp;
                p = p-&gt;next;
                h2 = h2-&gt;next;
            }
            // 最后是否有进位
            if (r != 0)
            {
                ListNode * tmp = new ListNode(r);
                p-&gt;next = tmp;
                p = p-&gt;next;
            }
            p-&gt;next = NULL;
            break;
        }
        return h-&gt;next;
    }
};
</pre></div>


<h1 id="3-longest-substring-without-repeating-characters">3 Longest Substring Without Repeating Characters 【类动态规划】</h1>
<ul>
<li>计算<code>f[i]</code>时遍历<code>f[i-1]</code>的重复区间内，是否有和<code>s[i]</code>重复的字符。其中<code>f[i]</code>代表以<code>i</code>字符结尾的字符串的最长不重复字符串</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if (s.size() &lt;= 1)
            return s.size();
        vector&lt;int&gt; f(s.size(), 0);
        f[0] = 1;
        int maxLength = 1;
        for (int i = 1; i &lt; s.size(); ++i)
        {
            int j;
            for ( j= i - 1; j &gt; i - 1 - f[i-1]; --j)
            {
                if (s[i] == s[j])
                {            
                    break;
                }
            }    
            f[i] = i - j;
            if (f[i] &gt; maxLength)
                maxLength = f[i];
        }
        return maxLength;
    }
};
</pre></div>


<h1 id="4-median-of-two-sorted-arrays">4 Median of Two Sorted Arrays  【！重要的思路！】</h1>
<ul>
<li>思路讲解： http://blog.csdn.net/hk2291976/article/details/51107778</li>
<li>对于两个数组，我们选择一个分割点<code>C1</code>，<code>C2</code>，记左边最大的是<code>L</code>，右边最小的是<code>R</code>，则可以得到<code>L1</code>，<code>L2</code>，<code>R1</code>，<code>R2</code></li>
<li>我们需要的是<code>L1&lt; R2 &amp;&amp; L2&lt; R1</code></li>
<li>如果不满足，移动<code>C1</code>或者<code>C2</code>，然后进行二分</li>
<li>由于需要判断奇偶数，我们对每个数组数字之间和首尾插入#，这样就可以不区别奇偶数</li>
<li>我们选择<code>C1</code>，那<code>C2= k-C1</code>，如果需要找的是第k个的时候</li>
<li>每次迭代是二分，因此总的就是<code>log(n)</code></li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        int len1 = nums1.size();
        int len2 = nums2.size();
        if (len1 &gt; len2)
            return findMedianSortedArrays(nums2, nums1);
        int L1, R1, L2, R2, c1, c2, Low, High;
        High = len1 * 2;
        Low = 0;
        while (Low &lt;= High)
        {
            c1 = (Low + High) / 2;        // 对数组1进行划分
            c2 = len1 + len2 - c1;
            L1 = (c1 == 0) ? INT_MIN : nums1[(c1 - 1) / 2];        // 分别是左右的第一个数，如果划分在数字上，两者相等
            R1 = (c1 == 2 * len1) ? INT_MAX : nums1[(c1) / 2];
            L2 = (c2 == 0) ? INT_MIN : nums2[(c2 - 1) / 2];
            R2 = (c2 == 2 * len2) ? INT_MAX : nums2[(c2) / 2];
            if (L1 &gt; R2)
            {
                High = c1-1;
            }
            else if (L2 &gt; R1)
            {
                Low = c1+1;
            }
            else
                break;
        }
        return (max(L1, L2) + min(R1, R2)) / 2.0;
    }
};
</pre></div>


<h1 id="5-longest-palindromic-substring">5 Longest Palindromic Substring</h1>
<ol>
<li>用一个数组记录每一个位置结尾的最长回文串</li>
<li>计算出对称轴<code>axis</code></li>
<li>如果<code>s[i]</code>和轴对称的另外一个<code>s[]</code>相同，<code>f[i]=f[i-1]+2</code></li>
<li>否则从<code>axis</code>开始，往右移动对称轴，判断是否是回文串。</li>
</ol>
<div class="codehilite"><pre>class Solution {
public:
    string longestPalindrome(string s) {
        if (s.size() &lt;= 1)
            return s;
        string maxStr;
        int maxLength=1;
        vector&lt;int&gt; f(s.size(), 1);
        maxStr = s[0];
        for (int i = 1; i &lt; s.size(); ++i)
        {
            float axis = (i-1-f[i-1]+1+i-1)/2.0;
            if (2 * axis - i &gt;= 0 &amp;&amp; s[2 * axis - i] == s[i])
            {
                f[i] = f[i - 1] + 2;
                if (f[i] &gt; maxLength)
                {
                    maxLength = f[i];
                    maxStr = s.substr(i - f[i] + 1, f[i]);
                }
            }
            else
            {
                axis += 0.5;
                while (axis &lt;= i)
                {
                    bool f = true;
                    for (int j = i; j &gt;= axis; --j)
                    {
                        if (s[j] != s[2 * axis - j])
                        {
                            f = false;
                            break;
                        }
                    }
                    if (f)
                        break;
                    axis += 0.5;
                }
                f[i] = (i - axis) * 2 + 1;
                if (f[i] &gt; maxLength)
                {
                    maxLength = f[i];
                    maxStr = s.substr(i - f[i] + 1, f[i]);
                }
            }
        }
        return maxStr;
    }
};
</pre></div>


<h1 id="6-zigzag-conversion">6 ZigZag Conversion</h1>
<ul>
<li>先正向往下走</li>
<li>斜向往上走</li>
<li>注意每一步判断是否已经结尾</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    string convert(string s, int numRows) {
        vector&lt;string&gt; vs(numRows);
        int len = s.size();
        bool direction = true;        //表示方向，true代表向下
        int idx=0;            // 记录总的string的index
        while (true)
        {
            if (idx &gt;= len)
                break;
            // 正向往下走
            if (direction)
            {
                for (int i = 0; i &lt; numRows; i++)
                {
                    if (idx &lt; len)
                        vs[i] += s[idx++];
                    else
                        break;
                }
                direction = !direction;
            }
            // 斜向往上走
            else
            {
                for (int i = numRows - 2; i &gt; 0; i--)
                {
                    if (idx &lt; len)
                        vs[i] += s[idx++];
                    else
                        break;
                }
                direction = !direction;
            }
        }
        // 合并字符串
        string str;
        for (int i = 0; i &lt; numRows; i++)
            str += vs[i];
        return str;
    }
};
</pre></div>


<h1 id="7-reverse-integer">7 Reverse Integer</h1>
<ul>
<li>注意符号和溢出</li>
<li>使用<code>long long</code>即可解决</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    int reverse(int x) {
        long long num = x;
        bool f = true;
        if (num &lt; 0)
        {
            num = -num;
            f = false;
        }    
        long long number = 0;
        while (num)
        {
            number *= 10;
            number += num % 10;
            num /= 10;
        }
        if (!f)
            number = -number;
        if (number &gt; INT_MAX)
            number = 0;
        if (number &lt; INT_MIN)
            number = 0;
        return number;
    }
};
</pre></div>


<h1 id="8-string-to-integer-atoi">8 String to Integer (atoi) 【细节多】</h1>
<ul>
<li>使用<code>long long</code>防止溢出</li>
<li>前面的空格</li>
<li>符号位</li>
<li><strong>遇到非数字结束转换，以前面的为准</strong></li>
<li>注意<code>int</code>的边界值</li>
</ul>
<p><strong>一些示例输入</strong></p>
<div class="codehilite"><pre>Input                 Output        Expected
&quot;    b11228552307&quot;    2147483647    0
&quot;+-2&quot;                 2            0
&quot;  -0012a42&quot;         0            -12
&quot;   +0 123&quot;             123        0
&quot; 10522545459&quot;         1932610867    2147483647
</pre></div>


<p><strong>代码</strong></p>
<div class="codehilite"><pre>class Solution {
public:
    int myAtoi(string str) {
        int len = str.size();
        // 使用long long 防止溢出
        long long tmp =0;
        bool f = true;
        int i = 0;
        // 去掉前面的空格
        while (str[i] == &#39; &#39;)
            i++;
        // 如果有符号位
        if (str[i] == &#39;-&#39;)
        {
            f = false;
            i++;
        }
        else
        {
            if (str[i] == &#39;+&#39;)
            {
                f = true;
                i++;
            }
            else if (str[i] &gt; &#39;9&#39; || str[i] &lt; &#39;0&#39;)
                return tmp;
        }
        for (; i &lt; len; i++)
        {
            int data = (str[i] - &#39;0&#39;);
            // 遇到一个非数字，不往下搜索，以前面得到的数字为准
            if (data &lt; 0 || data &gt;= 10)
            {
                break;
            }
            tmp *= 10;
            tmp += data;
            // 判断int 的边界值
            if (f)
            {
                if (tmp &gt; 2147483647)
                {
                    tmp = 2147483647;
                    break;
                }
            }
            else
            {
                if (tmp &gt;= 2147483648)
                {
                    tmp = 2147483648;
                    break;
                }
            }            
        }
        if (f)
            return tmp;
        return -tmp;
    }
};
</pre></div>


<h1 id="9-palindrome-number">9 Palindrome Number 【考虑溢出】</h1>
<ul>
<li>转化成<code>long long</code></li>
<li>逆序，比较是否相等</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    bool isPalindrome(int x) {
        long long num = x;
        if (num &lt; 0)
            return false;
        long long num2 =0;
        while (num)
        {
            num2 *= 10;
            num2 += num % 10;
            num /= 10;
        }
        num = x;
        if (num == num2)
            return true;
        return false;
    }
};
</pre></div>


<h1 id="10-regular-expression-matching">10 Regular Expression Matching 【动态规划】</h1>
<h2 id="_1">自己的解法</h2>
<ul>
<li>类似于动态规划，使用记忆化的数组，防止重复的搜索</li>
<li>具体的业务细节见代码，逻辑略复杂</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    int ** f;       // 使用一个记录数组，防止重复的递归

    bool solve(int idx1,int idx2,string s, string p)
    {
        if (idx1 == s.size())
        {
            if (idx2 == p.size())
                return true;
            else
            {
                bool f1 = true;
                bool f2 = true;
                // 对应于s已经匹配玩，p没有匹配完的，必须是* 结尾，必须隔一个是*
                for (int i = idx2+1; i &lt; p.size(); i = i + 2)
                {
                    if (p[i] != &#39;*&#39;)
                    {
                        f1 = false;
                        break;
                    }
                }
                for (int i = idx2; i &lt; p.size(); i = i + 2)
                {
                    if (p[i] != &#39;*&#39;)
                    {
                        f2 = false;
                        break;
                    }
                }
                if (p[p.size() - 1] != &#39;*&#39;)
                    return false;
                return f1 || f2;
            }            
        }            
        if (idx2 == p.size())
            return false;
        // 返回
        if (f[idx1][idx2] != -1)
            return f[idx1][idx2];
        char c1 = s[idx1];
        char c2 = p[idx2];
        // 如果两个相等，都往后推进
        if (c1 == c2 || c2==&#39;.&#39;)
        {
            bool f1 = solve(idx1 + 1, idx2 + 1, s, p);
            bool f2 = solve(idx1, idx2 + 2, s, p);
            // 后面是* 的话  可以选择跨越或者都往前进一格
            if (idx2 &lt; p.size() - 1 &amp;&amp; p[idx2 + 1] == &#39;*&#39;)
            {
                f[idx1][idx2] = f1 || f2;
                return f1 || f2;
            }            
            else
            {
                f[idx1][idx2] = f1;
                return f1;
            }            
        }
        else
        {        
            // 如果等于*，看前一个是否相等，并且可以选择指针移动或者不移动
            if (c2 == &#39;*&#39;)
            {
                bool f1 = solve(idx1 + 1, idx2 + 1, s, p);      
                bool f2 = solve(idx1 + 1, idx2, s, p);
                bool f3 = solve(idx1, idx2 + 1, s, p);
                if (idx2 &gt;= 1 &amp;&amp; (p[idx2 - 1] == &#39;.&#39; || p[idx2 - 1] == c1))
                {
                    f[idx1][idx2] = f1 || f2 || f3;  // f1 前面的相同，共同推进，f2 由于.的存在，直接s后推，f3 *对应于前一个字符的，p后推
                    return f1 || f2 || f3;
                }
                f[idx1][idx2] = f3;
                return f3;
                //return solve(idx1, idx2 + 1, s, p);
            }
            else
            {
                bool f1 = solve(idx1, idx2 + 2, s, p);          // 后面跟了个* 直接s推进两格   
                // 不同，但是后面跟了*
                if (idx2 &lt; p.size() - 1 &amp;&amp; p[idx2+1]==&#39;*&#39;)
                {
                    f[idx1][idx2] = f1;
                    return f1;
                }
            }
        }
        f[idx1][idx2] = 0;
        return false;
    }

    bool isMatch(string s, string p) {
        int len1 = s.size();
        int len2 = p.size();
        int idx1 = 0;
        int idx2 = 0;
        f = new int *[len1];
        for (int i = 0; i &lt; len1; i++)
        {
            f[i] = new int[len2];
            memset(f[i], -1, sizeof(int)*len2);
        }        
        return solve(idx1, idx2, s, p);
    }

};
</pre></div>


<h2 id="_2">别人的解法一  回溯，递归调用</h2>
<ul>
<li><strong>从后往前匹配</strong>  不需要判断后面一个是否是*</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    static const int FRONT=-1;
    bool isMatch(string s, string p) {
        return myMatch(s,s.length()-1,p,p.length()-1);
    }
    bool myMatch(string s, int i, string p,int j)
    {
        if(j == FRONT)
            if(i == FRONT)    return true;
        else return false;
// 遇到的是*
        if(p[j] == &#39;*&#39;)
        {
            if(i &gt; FRONT &amp;&amp; (p[j-1] == &#39;.&#39; || p[j-1] == s[i]))
                if(myMatch(s,i-1,p,j))
                    return true;
            return myMatch(s,i,p,j-2);
        }
// 遇到不是*
        if(p[j] == &#39;.&#39; || p[j] == s[i])
            return myMatch(s,i-1,p,j-1);
        return false;
    }
};
</pre></div>


<h2 id="_3">别人的解法二 动态规划，使用数组</h2>
<ul>
<li><code>dp[i][j]</code>的含义是<code>s[0-i]</code>与<code>s[0-j]</code>是否匹配</li>
<li>转移方程</li>
</ul>
<div class="codehilite"><pre>p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1]

If p.charAt(j) == ‘.’ : dp[i][j] = dp[i-1][j-1];

If p.charAt(j) == ‘*’: 
here are two sub conditions: 
if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2] //in this case, a* only counts as empty
if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == ‘.’:
dp[i][j] = dp[i-1][j] //in this case, a* counts as multiple a
dp[i][j] = dp[i][j-1] // in this case, a* counts as single a
dp[i][j] = dp[i][j-2] // in this case, a* counts as empty
</pre></div>


<ul>
<li>初始化数组</li>
</ul>
<div class="codehilite"><pre>dp[0][0] = true;
//初始化第0行,除了[0][0]全为false，毋庸置疑，因为空串p只能匹配空串，其他都无能匹配
for (int i = 1; i &lt;= m; i++) 
    dp[i][0] = false; 
//初始化第0列，只有X*能匹配空串，如果有*，它的真值一定和p[0][j-2]的相同（略过它之前的符号）
for (int j = 1; j &lt;= n; j++) 
    dp[0][j] = j &gt; 1 &amp;&amp; &#39;*&#39; == p[j - 1] &amp;&amp; dp[0][j - 2];
</pre></div>


<ul>
<li>完整代码</li>
</ul>
<div class="codehilite"><pre>class Solution
{
public:
    static const int FRONT=-1;
    bool isMatch(string s, string p)
    {
        int m = s.length(),n = p.length();
        bool dp[m+1][n+1];
        dp[0][0] = true;
//初始化第0行,除了[0][0]全为false，毋庸置疑，因为空串p只能匹配空串，其他都无能匹配
        for (int i = 1; i &lt;= m; i++)
            dp[i][0] = false;
//初始化第0列，只有X*能匹配空串，如果有*，它的真值一定和p[0][j-2]的相同（略过它之前的符号）
        for (int j = 1; j &lt;= n; j++)
            dp[0][j] = j &gt; 1 &amp;&amp; &#39;*&#39; == p[j - 1] &amp;&amp; dp[0][j - 2];

        for (int i = 1; i &lt;= m; i++)
        {
            for (int j = 1; j &lt;= n; j++)
            {
                if (p[j - 1] == &#39;*&#39;)
                {
                    dp[i][j] = dp[i][j - 2] || (s[i - 1] == p[j - 2] || p[j - 2] == &#39;.&#39;) &amp;&amp; dp[i - 1][j];

                }
                else  //只有当前字符完全匹配，才有资格传递dp[i-1][j-1] 真值
                {
                    dp[i][j] = (p[j - 1] == &#39;.&#39; || s[i - 1] == p[j - 1]) &amp;&amp; dp[i - 1][j - 1];

                }
            }
        }
        return dp[m][n];
    }
};
</pre></div>


<h1 id="11-container-with-most-water">11 Container With Most Water</h1>
<ul>
<li>如果完全遍历，需要<code>n^2</code>的复杂度</li>
<li>扫描一遍，从两边往中间扫描</li>
<li>不等时移动较小的边，相等时移动到较大的边</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    int maxArea(vector&lt;int&gt;&amp; height) {
        int len = height.size();
        int sum = 0;
        int l = 0,r = len - 1;
        while (l &lt; r)
        {
            int s = min(height[r], height[l])*(r-l);
            sum = max(s, sum);
            // 选择移动较小的一个边
            if (height[r] &lt; height[l])
            {
                r--;
            }
            else if (height[r]&gt;height[l])
            {
                l++;
            }
            // 相等，选择移动到较大的一个边
            else
            {
                if (height[r - 1]&gt;height[l + 1])
                {
                    r--;
                }
                else
                {
                    l++;
                }
            }
        }
        return sum;
    }
};
</pre></div>


<h1 id="12-integer-to-roman">12 Integer to Roman</h1>
<ol>
<li><code>I</code>(1),<code>V</code>(5),<code>X</code>(10),<code>L</code>(50),<code>C</code>(100),<code>D</code>(500),<code>M</code>(1000)</li>
<li>左减右加</li>
<li>左减<code>I</code>,<code>X</code>,<code>C</code></li>
<li>左减不得跨位，不超过一位</li>
<li>右加不超过三位</li>
<li>测试范围<code>1-3999</code></li>
</ol>
<div class="codehilite"><pre>class Solution {
public:
    string intToRoman(int num) {
        vector&lt;vector&lt;char&gt; &gt; f;
        f.push_back({&#39;I&#39;,&#39;V&#39;,&#39;X&#39;});
        f.push_back({ &#39;X&#39;, &#39;L&#39;, &#39;C&#39; });
        f.push_back({ &#39;C&#39;, &#39;D&#39;, &#39;M&#39; });
        f.push_back({ &#39;M&#39; });
        int idx = 0;
        string s;
        while (num)
        {
            int c = num % 10;
            num /= 10;
            switch (c)
            {
            case 0: break;
            case 1: s += f[idx][0]; break;
            case 2: s += f[idx][0]; s += f[idx][0]; break;
            case 3: s += f[idx][0]; s += f[idx][0]; s += f[idx][0]; break;
            case 4: s += f[idx][1]; s += f[idx][0]; break;
            case 5: s += f[idx][1]; break;
            case 6: s += f[idx][0]; s += f[idx][1]; break;
            case 7: s += f[idx][0]; s += f[idx][0]; s += f[idx][1]; break;
            case 8: s += f[idx][0]; s += f[idx][0]; s += f[idx][0]; s += f[idx][1]; break;
            case 9: s += f[idx][2]; s += f[idx][0]; break;
            default:
                break;
            }        
            ++idx;
            if (idx == 3)        // 千位的特殊情况
            {
                c = num % 10;
                switch (c)
                {
                case 0: break;
                case 1: s += f[idx][0]; break;
                case 2: s += f[idx][0]; s += f[idx][0]; break;
                case 3: s += f[idx][0]; s += f[idx][0]; s += f[idx][0]; break;            
                default:
                    break;
                }
                break;
            }
        }
        reverse(s.begin(), s.end());
        return s;
    }
};
</pre></div>


<h1 id="13-roman-to-integer">13 Roman to Integer</h1>
<ul>
<li>记录上一位，如果上一位小于这一位，是左减，需要减两次（因为前面加过一次）</li>
<li>否则直接累加即可</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    int romanToInt(string s) {
        unordered_map&lt;char, int&gt; priority;
        priority[&#39;I&#39;] = 1;
        priority[&#39;V&#39;] = 5;
        priority[&#39;X&#39;] = 10;
        priority[&#39;L&#39;] = 50;
        priority[&#39;C&#39;] = 100;
        priority[&#39;D&#39;] = 500;
        priority[&#39;M&#39;] = 1000;
        int sum =priority[s[0]];
        int last_v = priority[s[0]];
        for (int i = 1; i &lt; s.size(); ++i)
        {
            // 前一位小于后一位，则进行减操作，之前加过一次，因此减两次
            if (priority[s[i - 1]] &lt; priority[s[i]])
            {
                sum += priority[s[i]];
                sum -= last_v;
                sum -= last_v;
            }
            else
            {
                sum += priority[s[i]];
            }
            last_v = priority[s[i]];
        }
        return sum;
    }
};
</pre></div>


<h1 id="14-longest-common-prefix">14 Longest Common Prefix</h1>
<ul>
<li>最长的公共前缀</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {
        string s;
        if (strs.size() == 0)
            return s;
        int minLen = INT_MAX;
        for (int i = 0; i &lt; strs.size(); i++)
        {
            if (strs[i].size() &lt; minLen)
                minLen = strs[i].size();
        }
        for (int i = 0; i &lt; minLen; i++)
        {
            int c = strs[0][i];
            for (int j = 0; j &lt; strs.size(); j++)
            {
                if (strs[j][i] != c)
                    return s;
            }
            s += c;
        }
        return s;
    }
};
</pre></div>


<h1 id="15-3sum">15 3sum</h1>
<ul>
<li>先进行排序</li>
<li>控制一个数，然后得到头尾指针，分别向中间移动</li>
<li>使用<code>set</code>进行判重</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        int len = nums.size();
        vector&lt;vector&lt;int&gt; &gt;  vvi;
        set&lt;vector&lt;int&gt; &gt; svi;    
        for (int i = 0; i &lt; len - 2; i++)
        {
            // 确定一个数后从前后开始搜索
            int begin = i + 1;
            int end = len - 1;
            while (begin &lt; end)
            {
                if (nums[i] + nums[begin] + nums[end] == 0)
                {
                    vector&lt;int&gt; vi;
                    vi.push_back(nums[i]);
                    vi.push_back(nums[begin]);
                    vi.push_back(nums[end]);
                    svi.insert(vi);
                    // 移动前后指针
                    begin++;
                    end--;
                }
                else if (nums[i] + nums[begin] + nums[end] &lt; 0)
                {
                    begin++;
                }
                else
                {
                    end--;
                }
            }
        }
        // 复制到vector
        for (set&lt;vector&lt;int&gt; &gt; ::iterator it = svi.begin(); it != svi.end(); it++)
        {
            vvi.push_back(*it);
        }    
        return vvi;
    }
};
</pre></div>


<h1 id="16-3sum-closest">16 3Sum Closest</h1>
<ul>
<li>主体思路同15题</li>
<li>不需要判重，只需要记录最短距离和最短距离时的和即可</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {
        sort(nums.begin(), nums.end());
        int len = nums.size();
        int Min = INT_MAX;
        int MinVal=0;
        for (int i = 0; i &lt; len - 2; i++)
        {
            int begin = i + 1;
            int end = len - 1;
            while (begin &lt; end)
            {
                int v = nums[i] + nums[begin] + nums[end];
                if ( v== target)
                {
                    return target;
                }
                else if (v-target&lt;0)
                {
                    if (abs(v- target) &lt; Min)
                    {
                        Min = abs(v - target);
                        MinVal = v;
                    }
                    begin++;
                }
                else
                {
                    if (abs(v- target) &lt; Min)
                    {
                        Min = abs(v - target);
                        MinVal = v;
                    }
                    end--;
                }
            }
        }
        return MinVal;
    }
};
</pre></div>


<h1 id="17-letter-combinations-of-a-phone-number">17 Letter Combinations of a Phone Number</h1>
<h2 id="_4">解法一</h2>
<ul>
<li>递归搜索</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    void solve(int idx, string digits, vector&lt;string&gt;&amp; pattern, vector&lt;string&gt;&amp; vs,string &amp;s)
    {
        if (idx == digits.size())
        {
            vs.push_back(s);
            return;
        }
        int c = digits[idx] - &#39;0&#39;;
        for (int i = 0; i &lt; pattern[c].size(); ++i)
        {
            s.push_back(pattern[c][i]);
            solve(idx + 1, digits, pattern, vs, s);
            s.pop_back();
        }
    }

    vector&lt;string&gt; letterCombinations(string digits) {
        vector&lt;string&gt; pattern;
        vector&lt;string&gt; vs;
        if (digits.size() == 0)
            return vs;
        string s;
        pattern.push_back(&quot;&quot;);
        pattern.push_back(&quot;&quot;);//1
        pattern.push_back(&quot;abc&quot;);
        pattern.push_back(&quot;def&quot;);
        pattern.push_back(&quot;ghi&quot;);
        pattern.push_back(&quot;jkl&quot;);
        pattern.push_back(&quot;mno&quot;);
        pattern.push_back(&quot;pqrs&quot;);
        pattern.push_back(&quot;tuv&quot;);
        pattern.push_back(&quot;wxyz&quot;);
        solve(0, digits, pattern, vs,s);
        return vs;
    }
};
</pre></div>


<h2 id="_5">解法二 循环</h2>
<ul>
<li>详见编程之美</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    vector&lt;string&gt; letterCombinations(string digits) {
        vector&lt;string&gt; pattern;
        vector&lt;string&gt; vs;
        if (digits.size() == 0)
            return vs;
        string s;
        pattern.push_back(&quot;&quot;);
        pattern.push_back(&quot;&quot;);//1
        pattern.push_back(&quot;abc&quot;);
        pattern.push_back(&quot;def&quot;);
        pattern.push_back(&quot;ghi&quot;);
        pattern.push_back(&quot;jkl&quot;);
        pattern.push_back(&quot;mno&quot;);
        pattern.push_back(&quot;pqrs&quot;);
        pattern.push_back(&quot;tuv&quot;);
        pattern.push_back(&quot;wxyz&quot;);
        int idxCnt[10] = { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 };
        vector&lt;int&gt; index(digits.size(), 0);        // 循环变量，第i个字符在i个字符串中的位置
        while (true)
        {
            s.clear();
            for (int i = 0; i &lt; digits.size(); ++i)
            {
                s += pattern[digits[i] - &#39;0&#39;][index[i]];
            }            
            vs.push_back(s);

            int j = 0;
            while (j&lt;digits.size())
            {
                if (index[j] &lt; idxCnt[digits[j] - &#39;0&#39;]-1)        // 注意是减一
                {
                    index[j]++;
                    break;
                }
                else
                {
                    index[j] = 0;        // 进入下一层循环
                    ++j;
                }
            }
            if (j &gt;= digits.size())        // 循环到最外一层
                break;
        }
        return vs;
    }

};
</pre></div>


<h1 id="18-4sum">18 4sum</h1>
<ul>
<li>选择两个数建立一个<code>map</code>，<code>map</code>的<code>key</code>是和，值是该值下的<code>pair</code>队列</li>
<li>任意遍历两个数，检查是否有<code>target-a-b</code>的key</li>
<li>使用<code>set</code>进行去重</li>
<li>注意可能会有相同的值，需要防止相同的<code>pair</code>选择两遍</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    // 判断某一个序列是否是其中的一个子集
    bool ifContainer(vector&lt;int&gt; nums, vector&lt;int&gt; tmp)
    {
        vector&lt;int&gt; vf(nums.size(), 0);
        bool f = true;
        for (int j = 0; j &lt; 4; j++)
        {
            bool ok = false;
            for (int k = 0; k &lt; nums.size(); k++)
            {
                if (tmp[j] == nums[k] &amp;&amp; vf[k] == 0)
                {
                    ok = true;
                    vf[k] = 1;
                    break;
                }
            }
            if (!ok)
            {
                f = false;
                break;
            }
        }
        return f;
    }

    vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {
        map&lt;int,vector&lt;pair&lt;int,int&gt; &gt; &gt; mp;
        sort(nums.begin(), nums.end());
        int len = nums.size();
        vector&lt;vector&lt;int&gt; &gt;  vvi;
        // 建立每两个数的map，map的key是和，值是该值下的pair队列
        for (int i = 0; i &lt; len-1; i++)
        {
            for (int j = i + 1; j &lt; len; j++)
            {        
                int v = nums[i] + nums[j];
                pair&lt;int,int&gt; p;
                p = make_pair(nums[i], nums[j]);
                mp[v].push_back(p);
            }
        }
        for (int i = 0; i &lt; len - 1; i++)
        {
            for (int j = i + 1; j &lt; len; j++)
            {
                int v = nums[i] + nums[j];
                v = target - v;
                vector&lt;pair&lt;int, int&gt; &gt; vp = mp[v];            
                if (vp.size() &gt; 0)
                {
                    // 防止一半时将自己算入其中
                    if (v == target / 2)
                    {
                        if (vp.size() == 1)
                            continue;
                        // 如果确实有多个相同的，仅算一个
                        bool tag = true;
                        for (int k = 0; k &lt; vp.size(); k++)
                        {
                            pair&lt;int, int&gt; p = vp[k];
                            if (p==make_pair(nums[i],nums[j]) &amp;&amp; tag)
                            {
                                tag = false;
                                continue;
                            }                                
                            vector&lt;int&gt; vi;
                            vi.push_back(nums[i]);
                            vi.push_back(nums[j]);
                            vi.push_back(p.first);
                            vi.push_back(p.second);
                            sort(vi.begin(), vi.end());
                            vvi.push_back(vi);
                        }
                    }
                    else
                    {
                        for (int k = 0; k &lt; vp.size(); k++)
                        {
                            pair&lt;int, int&gt; p = vp[k];
                            vector&lt;int&gt; vi;
                            vi.push_back(nums[i]);
                            vi.push_back(nums[j]);
                            vi.push_back(p.first);
                            vi.push_back(p.second);
                            sort(vi.begin(), vi.end());
                            vvi.push_back(vi);
                        }
                    }                
                }
            }
        }
        // 使用set进行去重
        set&lt;vector&lt;int&gt; &gt; svi;
        for (int i = 0; i &lt; vvi.size(); i++)
            svi.insert(vvi[i]);
        vvi.clear();
        for (set&lt;vector&lt;int&gt; &gt; ::iterator it = svi.begin(); it != svi.end(); it++)
        {
            vector&lt;int&gt; tmp = *it;
            if (ifContainer(nums,tmp))
                vvi.push_back(*it);
        }        
        return vvi;
    }
};
</pre></div>


<ul>
<li>更快速的方法</li>
<li>先进行排序</li>
<li>遍历<code>a,b,</code>通过类似2sum的那种方法，对<code>c,d,</code>进行移动操作</li>
<li>然后将结果存入到<code>set</code>中</li>
<li><strong>核心是排序后，控制两个sum，也就转化为了2sum的问题，因为可能会带来重复，需要用set进行存储。</strong></li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt; &amp;num, int target) {
        vector&lt;vector&lt;int&gt;&gt; out;
        set&lt;vector&lt;int&gt;&gt; res;
        if (num.size() &lt; 4)
            return out;
        sort(num.begin(), num.end());
        for (int i=0; i&lt;num.size()-3; i++)
        {

            for (int j =i+1;j&lt;num.size()-2;j++)
            {
                int begin = j+1;
                int end = num.size()-1;
// 控制了2sum的值，然后再剩下的序列中进行2sum的操作
                while(begin &lt; end){
                    int sum = num[i] + num[j] + num[begin] + num[end];
                    if (sum== target)
                    {
                        vector&lt;int&gt; tmp;
                        tmp.push_back(num[i]);
                        tmp.push_back(num[j]);
                        tmp.push_back(num[begin]);
                        tmp.push_back(num[end]);
                        res.insert(tmp);
                        begin++;
                        end--;
                    } 
                    else if(sum &lt; target)
                    {
                        begin++;
                    }else{
                        end--;
                    }
                }

            }
        }
        set&lt;vector&lt;int&gt;&gt;::iterator it = res.begin();  
        for(; it != res.end(); it++)  
            out.push_back(*it); 


    }
};
</pre></div>


<h1 id="19-remove-nth-node-from-end-of-list">19 Remove Nth Node From End of List 【链表】</h1>
<div class="codehilite"><pre>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        vector&lt;ListNode *&gt; vl;    
        // 生成一个自定义的头部和尾部节点
        ListNode * h = new ListNode(20);
        ListNode * r = NULL;    //尾部节点定义为空
        vl.push_back(h);
        vl[0]-&gt;next = head;
        while (head)
        {
            vl.push_back(head);
            head = head-&gt;next;
        }
        vl[vl.size() - 1]-&gt;next = r;
        vl.push_back(r);
        int len = vl.size();
        // 删除节点
        vl[len - n - 2]-&gt;next = vl[len - n];
        // 将尾部节点的next删除，如果删除的本身是尾部节点，将接到自定义的尾部节点，因此需要定义尾部节点为空
        vl[len - 2]-&gt;next = NULL;
        return vl[0]-&gt;next;
    }
};
</pre></div>


<h1 id="20-valid-parentheses">20 Valid Parentheses 【栈】</h1>
<ul>
<li>使用<code>si.top()</code>注意先判断是否为空</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    bool isValid(string s) {
        stack&lt;int&gt; si;
        bool f = true;
        for (int i = 0; i &lt; s.size(); i++)
        {
            if (s[i] == &#39;(&#39;)
                si.push(&#39;)&#39;);
            else if (s[i] == &#39;{&#39;)
                si.push(&#39;}&#39;);
            else if (s[i] == &#39;[&#39;)
                si.push(&#39;]&#39;);
            else
            {
                if (si.empty())
                {
                    f = false;
                    break;
                }
                if (si.top() != s[i])
                {
                    f = false;
                    break;
                }
                si.pop();
            }
        }
        if (!si.empty())
            f = false;
        return f;
    }
};
</pre></div>


<h1 id="21-merge-two-sorted-lists">21 Merge Two Sorted Lists 【链表】</h1>
<ul>
<li>注意尾指针</li>
<li>使用一个自定义的头指针</li>
<li>访问指针前先判断是否为空</li>
</ul>
<div class="codehilite"><pre>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode * h = new ListNode(0);
        ListNode * p = h;
        while (l1 || l2)
        {
            while (l1 &amp;&amp; l2)
            {
                if (l1-&gt;val &lt; l2-&gt;val)
                {
                    p-&gt;next = l1;
                    p = p-&gt;next;
                    l1 = l1-&gt;next;
                }
                else
                {
                    p-&gt;next = l2;
                    p = p-&gt;next;
                    l2 = l2-&gt;next;
                }
            }
            while (l1)
            {
                p-&gt;next = l1;
                p = p-&gt;next;
                l1 = l1-&gt;next;
            }
            while (l2)
            {
                p-&gt;next = l2;
                p = p-&gt;next;
                l2 = l2-&gt;next;
            }
        }
        // 注意尾指针
        p-&gt;next = NULL;
        return h-&gt;next;
    }
};
</pre></div>


<h1 id="22-generate-parentheses">22 Generate Parentheses 【回溯法搜索】</h1>
<ul>
<li>搜索</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    vector&lt;string&gt; vs;
    string s;
    stack&lt;int&gt; si;
    void solve(int idx,int cnt, int n)
    {
        if (idx == 2*n)
        {
            vs.push_back(s);
            return;
        }    
        // 记录&#39;(&#39; 的次数
        if (cnt &lt; n)        
        {
            s.push_back(&#39;(&#39;);
            si.push(&#39;)&#39;);
            solve(idx + 1,cnt+1, n);
            s.pop_back();
            si.pop();
        }    
        // 如果可以弹出
        if (!si.empty())
        {
            s.push_back(&#39;)&#39;);
            si.pop();
            solve(idx + 1,cnt, n);
            si.push(&#39;)&#39;);
            s.pop_back();
        }    
    }

    vector&lt;string&gt; generateParenthesis(int n) {
        vs.clear();
        s.clear();
        while (!si.empty())
            si.pop();
        solve(0, 0,n);
        return vs;
    }
};
</pre></div>


<h1 id="23-merge-k-sorted-lists">23 Merge k Sorted Lists</h1>
<ul>
<li>需要保存一个固定大小的保持排序的数据结构，以<code>O(1)</code>获得最小值</li>
<li>可以选用<code>BST</code>，<code>AVL</code>，堆，标准库的集合，哈希等，这些都是维持排序的</li>
<li>由于可能有重复值，需要使用可以容纳重复值的容器</li>
<li>复杂度<code>O(n*logk)</code></li>
</ul>
<div class="codehilite"><pre>/**
* Definition for singly-linked list.
* struct ListNode {
*    int val;
*    ListNode *next;
*    ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
public:
    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {
        using PointX = pair&lt;ListNode *, int&gt;;
        auto f = [](const PointX &amp;p1, const PointX &amp;p2) -&gt;bool{ return p1.second &lt; p2.second; };
        ListNode * head = new ListNode(0);
        ListNode * tmp = head;
        // 允许重复值的集合
        multiset&lt;PointX, bool(*)(const PointX &amp;, const PointX &amp;)&gt; pSet(f);

        for (int i = 0; i &lt; lists.size(); ++i)
        {
            if (lists[i])
            {
                pSet.insert(PointX(lists[i], lists[i]-&gt;val));
            }
        }

        while (pSet.size() &gt; 0)
        {
            auto p = *(pSet.begin());
            tmp-&gt;next = p.first;
            tmp = tmp-&gt;next;

            pSet.erase(pSet.begin());      // 不能删除值，会把重复的全部删除，删除对应的迭代器
            if (p.first-&gt;next)
                pSet.insert(PointX(p.first-&gt;next, p.first-&gt;next-&gt;val));
        }
        // 尾指针置空
        tmp-&gt;next = nullptr;
        return head-&gt;next;    
    }
};
</pre></div>


<h1 id="24-swap-nodes-in-pairs">24 Swap Nodes in Pairs 【链表】</h1>
<ul>
<li>交换链表相邻值</li>
</ul>
<div class="codehilite"><pre>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode * h = head;
        while (h &amp;&amp; h-&gt;next)  // 一次判断到位
        {
            int v = h-&gt;val;
            h-&gt;val = h-&gt;next-&gt;val;
            h-&gt;next-&gt;val = v;
            h = h-&gt;next-&gt;next;
        }
        return head;
    }
};
</pre></div>


<h1 id="25-reverse-nodes-in-k-group">25 Reverse Nodes in k-Group 【链表】</h1>
<ul>
<li>使用一个头节点，便于头节点操作</li>
<li>注意链表的尾部节点，防止出现环或者没有尾巴</li>
</ul>
<div class="codehilite"><pre>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if (k == 0)
            return head;
        // 使用一个头指针
        ListNode * h = new ListNode(0);
        h-&gt;next = head;
        ListNode * p = h;
        vector&lt;ListNode *&gt; vl(k);
        while (head)
        {
            int cnt = 0;
            while (cnt &lt; k &amp;&amp; head)
            {
                vl[cnt++] = head;
                head = head-&gt;next;        
            }
            if (cnt &lt; k)
                break;
            // 将这个单元的最后一个指针的next存取起来
            ListNode * tmp = vl[cnt - 1]-&gt;next;
            for (int i = cnt - 1; i &gt;= 0; i--)
            {
                p-&gt;next = vl[i];
                p = p-&gt;next;            
            }
            // 复原指针尾巴
            p-&gt;next = tmp;
        }

        return h-&gt;next;
    }
};
</pre></div>


<h2 id="_6">翻转单链表的三种方法 【重要】</h2>
<ol>
<li>重新插入一遍，每次从头部插入</li>
<li>记录一个头部节点和初始位置，每次将初始位置后的节点翻转到头部，向前移动头节点</li>
<li>记录一个头部节点和初始位置，不断将头部节点翻转到初始位置的后面，向后移动头节点 【2.3 方法类似】</li>
</ol>
<h1 id="26-remove-duplicates-from-sorted-array">26 Remove Duplicates from Sorted Array【线性空间删除数组重复值】</h1>
<ul>
<li>两个指针：一个指向删除重复后的最后一个，一个指向原数组</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        if (nums.size() &lt;= 1)
            return nums.size();
        int l1 = 0;        // 数组指针
        int cnt = 1;    // 计数
        for (int i = 1; i &lt; nums.size(); ++i)
        {
            if (nums[i] != nums[l1])
            {
                nums[++l1] = nums[i];
                ++cnt;
            }
        }
        return cnt;
    }
};
</pre></div>


<h1 id="27-remove-element">27 Remove Element</h1>
<ul>
<li>线性空间，在自身复制</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {
        int cnt = 0;        // val的个数
        int idx1 = 0;       // 记录返回的有效位置
        int idx2 = 0;       // 移动的指针
        while (idx2 &lt; nums.size())
        {
            if (nums[idx2] == val)
            {
                idx2++;
                cnt++;
            }
            else
            {
                nums[idx1] = nums[idx2];
                idx1++;
                idx2++;
            }
        }
        return nums.size() - cnt;
    }
};
</pre></div>


<h1 id="28-implement-strstr">28 Implement strStr()</h1>
<div class="codehilite"><pre>class Solution {
public:
    int strStr(string haystack, string needle) {
        int len1 = haystack.size();
        int len2 = needle.size();
        if(len1 ==0 &amp;&amp; len2==0)
            return 0;
        if (len1 &lt; len2)
            return -1;
        for (int i = 0; i &lt;= len1 - len2; i++)
        {
            string s = haystack.substr(i, len2);
            if (s == needle)
                return i;
        }
        return -1;
    }
};
</pre></div>


<h1 id="29-divide-two-integers">29 Divide Two Integers 【数值计算，重要】</h1>
<ul>
<li>由于不能使用乘除，取余数，因此可以使用的是加减法和移位操作</li>
<li>一个整数可以这样表示：<code>num=a_0*2^0+a_1*2^1+a_2*2^2+...+a_n*2^n</code></li>
<li>我们先得到一个最大的不大于<code>num</code>的<code>a_0</code>的倍数，每次扩大两倍（移1位）</li>
<li>然后记录移动的位数，每次来减，记录总体的倍数即可</li>
<li>注意<code>int</code>的极限值，负值比正值多一位，注意区分正负，使用<code>long long</code>来记录防止越界</li>
</ul>
<h2 id="_7">自己的代码，不知道为啥没通过</h2>
<div class="codehilite"><pre>int divide(int dividend, int divisor) {
    // 除数为0 直接返回max
    if (divisor == 0)
        return INT_MIN;
    // 被除数为0 返回0
    if (dividend == 0)
        return 0;
    // 判断正负
    bool f = false;
    if ((dividend &gt; 0) &amp;&amp; (divisor &gt; 0) || (dividend &lt; 0) &amp;&amp; (divisor &lt; 0))
        f = true;
    // 使用long long 防止越界
    long long d1, d2;
    if (dividend == INT_MIN)
    {
        if (f)            // 如果同号的就得加一，int 负数表达范围会大一个
            d1 = abs(dividend + 1);
        else
            d1 = abs((long long)dividend);  // 如果结果是负的，就不能丢失精度
    }        
    else
        d1 = abs(dividend);
    // 
    if (divisor == INT_MIN)
    {
        if (f)
            d2 = abs(divisor + 1);
        else
            d2 = abs((long long)divisor);
    }        
    else
        d2 = abs(divisor);    
    if (d1 &lt; d2)
        return 0;
    if (d1 == d2)
    {
        if (f)
            return 1;
        return -1;
    }        
    int k=0;
    int cnt=0;
    long long d = d2;
    // 找到不大于d1的最大
    while (d &lt; d1)
    {
        d =d&lt;&lt;1;    //每次扩大2倍
        k++;        
    }
    d &gt;&gt;= 1;
    k--;
    while (d1)
    {
        if (d1 &gt;= d)    //如果可以减，需要增加1&lt;&lt;k个
        {
            d1 -= d;
            cnt += (1 &lt;&lt; k);            
        }
        else // 如果没法减，必须减小两倍
        {
            d &gt;&gt;= 1;
            k--;            
            if (d &lt; d2)
                break;
        }        
    }
    if (f)
        return cnt;
    return -cnt;
}
</pre></div>


<h2 id="_8">别人的代码通过</h2>
<div class="codehilite"><pre>class Solution {
public:
    int divide(int dividend, int divisor) {
        long long m = abs((long long)dividend), n = abs((long long)divisor), res = 0;
        if (m &lt; n) return 0;    
        while (m &gt;= n) {
            long long t = n, p = 1;
            while (m &gt; (t &lt;&lt; 1)) { // 每次找到最接近的不大于的n的倍数，注意判断时的技巧
                t &lt;&lt;= 1;
                p &lt;&lt;= 1;
            }
            res += p;
            m -= t;
        }
        // 判断符号
        if ((dividend &lt; 0) ^ (divisor &lt; 0)) res = -res;
        // 防止溢出
        return res &gt; INT_MAX ? INT_MAX : res;
    }
};
</pre></div>


<h2 id="_9">递归写法</h2>
<div class="codehilite"><pre>class Solution {
public:
    int divide(int dividend, int divisor) {
        long long res = 0;
        long long m = abs((long long)dividend), n = abs((long long)divisor);
        if (m &lt; n) return 0;
        long long t = n, p = 1;
        while (m &gt; (t &lt;&lt; 1)) {
            t &lt;&lt;= 1;
            p &lt;&lt;= 1;
        }
        res += p + divide(m - t, n);
        if ((dividend &lt; 0) ^ (divisor &lt; 0)) res = -res;
        return res &gt; INT_MAX ? INT_MAX : res;
    }
};
</pre></div>


<h1 id="34-search-for-a-range">34 Search for a Range 【二分法】</h1>
<ul>
<li>两遍二分法</li>
<li>分别找到最左边一个和最右边一个</li>
<li>注意判断0和1的极端情况</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {
        int len = nums.size();
        vector&lt;int&gt; v(2);
        v[0] = -1;
        v[1] = -1;
        // 一个和两个的极端情况
        if (len == 0)
            return v;
        if (len == 1)
        {
            if (target == nums[0])
            {
                v[0] = 0;
                v[1] = 0;
            }        
            return v;
        }    
        int l = -1;
        int r = len;
        int idx1 = -1,idx2 =-1;
        // 找到大于等于的最右一个
        while (l+1!= r)
        {
            int i = (l + r) / 2;
            if (target &lt; nums[i])
            {
                r = i;
            }
            else
            {
                l = i;
            }
        }    
        if (nums[l] != target)
            return v;
        idx2 = l;
        l = -1;
        r = len;
        // 找到小于等于的最左边一个
        while (l + 1 != r)
        {
            int i = (l + r) / 2;
            if (target &lt;= nums[i])
            {
                r = i;
            }
            else
            {
                l = i;
            }
        }
        idx1 = r;
        v[0] = idx1;
        v[1] = idx2;
        return v;
    }
};
</pre></div>


<h1 id="35-search-insert-position">35 Search Insert Position 【二分法】</h1>
<ul>
<li>标准的二分法，已经排序的数组</li>
<li>先将两个指针分别放在索引外围，一个-1，一个<mathjax>$nums.size()$</mathjax></li>
<li>两个相差1即停止</li>
<li>区别找到一个合适位置或者找到最前一个</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
        int l = -1;
        int r = nums.size();
        while (l != r - 1)
        {
            int mid = (l + r) / 2;
            if (nums[mid] &lt; target)
                l = mid;
            else
                r = mid;
        }
        return r;
    }
};
</pre></div>


<h1 id="36-valid-sudoku">36 Valid Sudoku</h1>
<ul>
<li>是否为有效的数独</li>
<li>不是搜索状态空间，直接判断当前的情况</li>
<li>分为三种情况，详见代码</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        // 当作三种遍历，一种是固定行，遍历列，一种是固定列，遍历行，还有一种是固定正方形的编号，遍历正方形内的编号
        for (int i = 0; i &lt; 9; i++)
        {
            // 分别对应于三种情况
            unordered_map&lt;int, bool&gt; m1;    
            unordered_map&lt;int, bool&gt; m2;
            unordered_map&lt;int, bool&gt; m3;

            for (int j = 0; j &lt; 9; j++)
            {
                // 固定行，遍历列
                if (board[i][j] != &#39;.&#39;)
                {
                    if (m1[board[i][j]] == true)
                        return false;
                    m1[board[i][j]] = true;
                }
                // 固定列，遍历行
                if (board[j][i] != &#39;.&#39;)
                {
                    if (m2[board[j][i]] == true)
                        return false;
                    m2[board[j][i]] = true;
                }
                // 第i个正方形的第j个格子  分别求出对应的行列号
                if (board[i / 3 * 3 + j / 3][i % 3 * 3 + j % 3] != &#39;.&#39;)
                {
                    if (m3[board[i / 3 * 3 + j / 3][i % 3 * 3 + j % 3]] == true)
                        return false;
                    m3[board[i / 3 * 3 + j / 3][i % 3 * 3 + j % 3]] = true;
                }
            }
        }
        return true;
    }
};
</pre></div>


<h1 id="37-sudoku-solver">37 Sudoku Solver 【九宫格算法】</h1>
<ul>
<li>按照行搜索</li>
<li>先检测该点是否符合，符合的话进行往下继续搜索，记住如果不符合需要改回原来的<mathjax>$.$</mathjax>标识</li>
<li>需要检测行是否矛盾，列是否矛盾，所在格子是否矛盾</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    // 检测这个位置是否不符合要求
    bool isValid(vector&lt;vector&lt;char&gt; &gt; &amp;board, int x, int y)
    {
        int i, j;
        // 每一行
        for (i = 0; i &lt; 9; i++)
            if (i != x &amp;&amp; board[i][y] == board[x][y])
                return false;
        // 每一列
        for (j = 0; j &lt; 9; j++)
            if (j != y &amp;&amp; board[x][j] == board[x][y])
                return false;
        // 每一个九宫格
        for (i = 3 * (x / 3); i &lt; 3 * (x / 3 + 1); i++)
            for (j = 3 * (y / 3); j &lt; 3 * (y / 3 + 1); j++)
                if (i != x &amp;&amp; j != y &amp;&amp; board[i][j] == board[x][y])
                    return false;
        return true;
    }

    // 从哪一行开始继续搜索，减小部分复杂度
    bool solve(vector&lt;vector&lt;char&gt;&gt;&amp; board,int idx)
    {
        for (int i = idx; i &lt; 9; ++i)   // 一行一行搜索的
            for (int j = 0; j &lt; 9; ++j)
            {
                if (&#39;.&#39; == board[i][j])
                {
                    for (int k = 1; k &lt;= 9; ++k)
                    {
                        board[i][j] = &#39;0&#39; + k;
                        // 从这个位置开始搜索
                        if (isValid(board, i, j) &amp;&amp; solve(board,i))
                            return true;
                        board[i][j] = &#39;.&#39;;
                    }
                    return false;
                }
            }
        return true;
    }

    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board)
    {
        solve(board, 0);
    }
};
</pre></div>


<h1 id="42-trapping-rain-water">42 Trapping Rain Water</h1>
<ul>
<li>找到最大位置</li>
<li>从左往右</li>
<li>从右往左</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        if(height.size()&lt;=1)
            return 0;
        int maxHeight = -1;
        int sum = 0;
        int idx=-1;
        // 找到最大值的位置
        for (int i = 0; i &lt; height.size(); i++)
        {
            if (height[i] &gt; maxHeight)
            {
                maxHeight = height[i];
                idx = i;
            }            
        }
        // 从左往右
        int maxh = height[0];
        for (int i = 0; i &lt; idx; i++)
        {
            if (maxh &gt;= height[i])
            {
                sum += maxh - height[i];
            }
            else
            {
                maxh = height[i];
            }
        }
        // 从右往左
        maxh = height[height.size() - 1];
        for (int i = height.size() - 1; i &gt; idx; i--)
        {
            if (maxh &gt;= height[i])
            {
                sum += maxh - height[i];
            }
            else
            {
                maxh = height[i];
            }
        }
        return sum;
    }
};
</pre></div>


<h1 id="45-jump-game-ii">45 Jump Game II</h1>
<ul>
<li>遍历数组，到达该位置的步数等于能到达这个位置的最小的一个前值+1</li>
<li>因此只需要记录上一次到达的最小位置</li>
<li>然后从这个位置开始搜索，递增，满足的第一个就记录下来</li>
<li>不然会超时</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    int jump(vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; minDis(nums.size(), 0);
        int idx = 0;
        for (int i = 1; i &lt; nums.size(); i++)
        {
            int v=INT_MAX;
            int lowBound = idx;
            for (int j = lowBound; j &lt; i; j++)
            {
                // 可以到达i点，由于minDis[a]&lt;minDis[b]如果a&lt;b的话，因此第一个满足条件的即可
                if (nums[j] + j &gt;= i)
                {                
                    idx = j;                
                    v = minDis[j] + 1;
                    break;
                }
            }
            minDis[i] = v;
        }
        return minDis[nums.size() - 1];
    }
};
</pre></div>


<h1 id="46-permutations">46 Permutations 【搜索】</h1>
<ul>
<li>使用set记录所有的元素</li>
<li>使用map记录元素出现的次数，防止出现冗余</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:

    vector&lt;vector&lt;int&gt; &gt;  vs;
    vector&lt;int&gt; v;
    void solve(vector&lt;int&gt; s, int idx, map&lt;int, int&gt; m,set&lt;int&gt; si)
    {
        if (idx == s.size())
        {
            vs.push_back(v);
            return;
        }
        for (auto it = si.begin();it!=si.end();++it)
        {
            if (m[*it] &gt; 0)
            {
                v.push_back(*it);
                m[*it]--;
                solve(s, idx + 1, m,si);
                m[*it]++;
                v.pop_back();
            }
        }
    }

    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {
        v.clear();
        vs.clear();       
        // 使用map存次数
        map&lt;int, int&gt; mi;
        // 使用set存出现的数字
        set&lt;int&gt; si;
        for (auto c : nums)            
        {
            mi[c] ++;
            si.insert(c);
        }
        solve(nums, 0, mi,si);
        return vs;
    }
};
</pre></div>


<h1 id="47-permutations-ii">47 Permutations II 【同样的题目，只是数字可能会重复，代码是相同】</h1>
<ul>
<li>加引用可以很大程度提升速度</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:

    vector&lt;vector&lt;int&gt; &gt;  vs;
    vector&lt;int&gt; v;
    void solve(vector&lt;int&gt; s, int idx, map&lt;int, int&gt; &amp;m,set&lt;int&gt; &amp;si)
    {
        if (idx == s.size())
        {
            vs.push_back(v);
            return;
        }
        for (auto it = si.begin();it!=si.end();++it)
        {
            if (m[*it] &gt; 0)
            {
                v.push_back(*it);
                m[*it]--;
                solve(s, idx + 1, m,si);
                m[*it]++;
                v.pop_back();
            }
        }
    }

    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {
        v.clear();
        vs.clear();       
        // 使用map存次数
        map&lt;int, int&gt; mi;
        // 使用set存出现的数字
        set&lt;int&gt; si;
        for (auto c : nums)            
        {
            mi[c] ++;
            si.insert(c);
        }
        solve(nums, 0, mi,si);
        return vs;
    }

};
</pre></div>


<h1 id="48-rotate-image">48 Rotate Image 【矩阵操作】</h1>
<h2 id="_10">方法一</h2>
<ul>
<li>单个旋转一圈</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();
        for (int i = 0; i &lt; n / 2; ++i)
        {
            for (int j = i; j &lt; n - i-1; ++j)
            {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[n - 1 - j][i];
                matrix[n - 1 - j][i] = matrix[n-1-i][n-1-j];
                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];
                matrix[j][n - 1 - i] = tmp;
            }
        }
    }
};
</pre></div>


<h2 id="_11">方法二</h2>
<ul>
<li>先按右对角线进行翻转</li>
<li>然后进行上下翻转，同样可以达到旋转功能</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();
        for(int i = 0; i &lt; n - 1; i++){//i只能取到 n - 2, 因为n - 1是对称轴
            for(int j = 0; j &lt; n - 1 - i; j++){//j只能取到n - 1 - i, 在对称轴的左边
                swap(matrix[i][j], matrix[n - 1 - j][n - 1 - i]);
            }
        }
        for(int i = 0; i &lt; n / 2; i++){//i只能取到横向中间轴的上面
            for(int j = 0; j &lt; n; j++){//j可以取到所有值
                swap(matrix[i][j], matrix[n - 1 - i][j]);//按横向轴翻转，j不变；i变为n-1-i
            }
        }
    }
};
</pre></div>


<h2 id="_12">方法三</h2>
<ul>
<li>先按作对角线进行翻转</li>
<li>然后进行左右翻转，达到同样旋转功能</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();
        for(int i = 0; i &lt; n; i++){
            for(int j = i + 1; j &lt; n; j++){//j取i - 1, 因为对称轴是（i,i）
                swap(matrix[i][j], matrix[j][i]);
            }
            reverse(matrix[i].begin(), matrix[i].end());//按竖向中轴线翻转 直接按行reverse即可
        }
    }
};
</pre></div>


<h1 id="49-group-anagrams">49 Group Anagrams 【哈希】</h1>
<ul>
<li>对单词的字母进行计数</li>
<li>将数组转为字符串然后进行哈希</li>
<li>获得需要结果</li>
</ul>
<div class="codehilite"><pre>class Solution {
public:
// 转化为字符串进行哈希
    string toString(vector&lt;int&gt; v)
    {
        string s;
        for (auto i : v)
        {
            s += to_string(i);
            s += &quot;_&quot;;
        }
        return s;
    }

    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {
        unordered_map&lt;string, vector&lt;string&gt; &gt; mvv;
        for (auto s : strs)
        {
            vector&lt;int&gt; v(26,0);
            for (auto c : s)
                v[c - &#39;a&#39;]++;
            string str = toString(v);
            mvv[str].push_back(s);
        }
        vector&lt;vector&lt;string&gt; &gt; vvs;
        for (auto d = mvv.begin(); d != mvv.end();++d)
        {
            vvs.push_back(d-&gt;second);
        }
        return vvs;
    }
};
</pre></div>


<h1 id="50-powxn">50 Pow(x,n) 【分治法，数值计算重要】</h1>
<ul>
<li>使用分治法</li>
<li>任何数的0次方都是1</li>
<li>注意区分正负</li>
<li><strong>如果递归式相同，减小递归式的书写，能合并的用一个值代替，减少分支数量</strong></li>
</ul>
<div class="codehilite"><pre>class Solution {
public:

    double solve(double x, int n) {
        if (n == 1)
            return x;
        if (n == 0)
            return 1;
        double v = solve(x, n / 2);
        if (n % 2)
            return v*v*x;
        else
            return v*v;
    }

    double myPow(double x, int n) {
        // 任何数的0次方都是1
        if (n == 0)
            return 1;
        if(n&gt;0)
            return solve(x, n);
        if(n&lt;0)
            return 1.0/solve(x,-n);
    }

};
</pre></div>
        </article>
      </div>
    </div>
  </body>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$', '$$'], ["\\[", "\\]"] ],
          processEscapes: true
        },
        TeX: {
          equationNumbers: {
            autoNumber: 'AMS'
          }
        },
        "HTML-CSS": {
          imageFont: null
        }
      });
  </script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/2.1-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</html>
