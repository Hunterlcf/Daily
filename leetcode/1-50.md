<!-- MarkdownTOC -->

- [1 Two Sum 【哈希】](#1-two-sum-%E3%80%90%E5%93%88%E5%B8%8C%E3%80%91)
- [2 Add Two Numbers 【链表】](#2-add-two-numbers-%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91)
- [3 Longest Substring Without Repeating Characters 【类动态规划】](#3-longest-substring-without-repeating-characters-%E3%80%90%E7%B1%BB%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91)
- [4 Median of Two Sorted Arrays  【！重要的思路！】](#4-median-of-two-sorted-arrays--%E3%80%90%EF%BC%81%E9%87%8D%E8%A6%81%E7%9A%84%E6%80%9D%E8%B7%AF%EF%BC%81%E3%80%91)
- [5 Longest Palindromic Substring](#5-longest-palindromic-substring)
- [6 ZigZag Conversion](#6-zigzag-conversion)
- [7 Reverse Integer](#7-reverse-integer)
- [8 String to Integer \(atoi\) 【细节多】](#8-string-to-integer-atoi-%E3%80%90%E7%BB%86%E8%8A%82%E5%A4%9A%E3%80%91)
- [9 Palindrome Number 【考虑溢出】](#9-palindrome-number-%E3%80%90%E8%80%83%E8%99%91%E6%BA%A2%E5%87%BA%E3%80%91)
- [10 Regular Expression Matching 【动态规划】](#10-regular-expression-matching-%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91)
	- [自己的解法](#%E8%87%AA%E5%B7%B1%E7%9A%84%E8%A7%A3%E6%B3%95)
	- [别人的解法一  回溯，递归调用](#%E5%88%AB%E4%BA%BA%E7%9A%84%E8%A7%A3%E6%B3%95%E4%B8%80--%E5%9B%9E%E6%BA%AF%EF%BC%8C%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8)
	- [别人的解法二 动态规划，使用数组](#%E5%88%AB%E4%BA%BA%E7%9A%84%E8%A7%A3%E6%B3%95%E4%BA%8C-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84)
- [11 Container With Most Water](#11-container-with-most-water)
- [12 Integer to Roman](#12-integer-to-roman)
- [13 Roman to Integer](#13-roman-to-integer)
- [14 Longest Common Prefix](#14-longest-common-prefix)
- [15 3sum](#15-3sum)
- [16 3Sum Closest](#16-3sum-closest)
- [17 Letter Combinations of a Phone Number](#17-letter-combinations-of-a-phone-number)
	- [解法一](#%E8%A7%A3%E6%B3%95%E4%B8%80)
	- [解法二 循环](#%E8%A7%A3%E6%B3%95%E4%BA%8C-%E5%BE%AA%E7%8E%AF)
- [18 4sum](#18-4sum)
- [19 Remove Nth Node From End of List 【链表】](#19-remove-nth-node-from-end-of-list-%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91)
- [20 Valid Parentheses 【栈】](#20-valid-parentheses-%E3%80%90%E6%A0%88%E3%80%91)
- [21 Merge Two Sorted Lists 【链表】](#21-merge-two-sorted-lists-%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91)
- [22 Generate Parentheses 【回溯法搜索】](#22-generate-parentheses-%E3%80%90%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%90%9C%E7%B4%A2%E3%80%91)
- [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
- [24 Swap Nodes in Pairs 【链表】](#24-swap-nodes-in-pairs-%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91)
- [25 Reverse Nodes in k-Group 【链表】](#25-reverse-nodes-in-k-group-%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91)
	- [翻转单链表的三种方法 【重要】](#%E7%BF%BB%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95-%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91)
- [26 Remove Duplicates from Sorted Array【线性空间删除数组重复值】](#26-remove-duplicates-from-sorted-array%E3%80%90%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E5%80%BC%E3%80%91)
- [27 Remove Element](#27-remove-element)
- [28 Implement strStr\(\)](#28-implement-strstr)
- [29 Divide Two Integers 【数值计算，重要】](#29-divide-two-integers-%E3%80%90%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%EF%BC%8C%E9%87%8D%E8%A6%81%E3%80%91)
	- [自己的代码，不知道为啥没通过](#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%B8%8D%E7%9F%A5%E9%81%93%E4%B8%BA%E5%95%A5%E6%B2%A1%E9%80%9A%E8%BF%87)
	- [别人的代码通过](#%E5%88%AB%E4%BA%BA%E7%9A%84%E4%BB%A3%E7%A0%81%E9%80%9A%E8%BF%87)
	- [递归写法](#%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95)
- [34 Search for a Range 【二分法】](#34-search-for-a-range-%E3%80%90%E4%BA%8C%E5%88%86%E6%B3%95%E3%80%91)
- [35 Search Insert Position 【二分法】](#35-search-insert-position-%E3%80%90%E4%BA%8C%E5%88%86%E6%B3%95%E3%80%91)
- [36 Valid Sudoku](#36-valid-sudoku)
- [37 Sudoku Solver 【九宫格算法】](#37-sudoku-solver-%E3%80%90%E4%B9%9D%E5%AE%AB%E6%A0%BC%E7%AE%97%E6%B3%95%E3%80%91)
- [42 Trapping Rain Water](#42-trapping-rain-water)
- [45 Jump Game II](#45-jump-game-ii)
- [46 Permutations 【搜索】](#46-permutations-%E3%80%90%E6%90%9C%E7%B4%A2%E3%80%91)
- [47 Permutations II 【同样的题目，只是数字可能会重复，代码是相同】](#47-permutations-ii-%E3%80%90%E5%90%8C%E6%A0%B7%E7%9A%84%E9%A2%98%E7%9B%AE%EF%BC%8C%E5%8F%AA%E6%98%AF%E6%95%B0%E5%AD%97%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%87%8D%E5%A4%8D%EF%BC%8C%E4%BB%A3%E7%A0%81%E6%98%AF%E7%9B%B8%E5%90%8C%E3%80%91)
- [48 Rotate Image 【矩阵操作】](#48-rotate-image-%E3%80%90%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C%E3%80%91)
	- [方法一](#%E6%96%B9%E6%B3%95%E4%B8%80)
	- [方法二](#%E6%96%B9%E6%B3%95%E4%BA%8C)
	- [方法三](#%E6%96%B9%E6%B3%95%E4%B8%89)
- [49 Group Anagrams 【哈希】](#49-group-anagrams-%E3%80%90%E5%93%88%E5%B8%8C%E3%80%91)
- [50 Pow\(x,n\) 【分治法，数值计算重要】](#50-powxn-%E3%80%90%E5%88%86%E6%B2%BB%E6%B3%95%EF%BC%8C%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E9%87%8D%E8%A6%81%E3%80%91)

<!-- /MarkdownTOC -->
[TOC]

# 1 Two Sum 【哈希】
- 先排序
- 然后从两端开始寻找
- 然后找到在原数组中的索引

```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> snums = nums;
// 先排序
        sort(nums.begin(), nums.end());
        int len = nums.size();
        int l = 0;
        int r = len-1;
// 然后从两端开始往中间寻找
        while (l < r)
        {
            if (nums[l] + nums[r]>target)
                r--;
            else if (nums[l] + nums[r] < target)
                l++;
            else
                break;
        }
        vector<int> f(len, 0);
        vector<int> v;
// 然后找到在原数组的索引
        for (int i = 0; i < len; i++)
        {
            if (nums[l] == snums[i] && !f[i])
            {
                f[i] = 1;
                v.push_back(i);
                break;
            }
        }
        for (int i = 0; i < len; i++)
        {
            if (nums[r] == snums[i] && !f[i])
            {
                f[i] = 1;
                v.push_back(i);
            }
        }
        return v;
    }
};
```

- 使用哈希表的思路
- 先建立每个数的哈希表
- 遍历每一个数，得到`sum-a`的值
- 然后再哈希表中查找是否有该值

```
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        map.put(nums[i], i);
    }
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement) && map.get(complement) != i) {
            return new int[] { i, map.get(complement) };
        }
    }
    throw new IllegalArgumentException("No two sum solution");
}
```

- 更快速的代码
- 只需要遍历一遍

```
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[] { map.get(complement), i };
        }
        map.put(nums[i], i);
    }
    throw new IllegalArgumentException("No two sum solution");
}
```

# 2 Add Two Numbers 【链表】

- 使用一个固定的表头，最后去掉，降低编程复杂性
- 最后一个进位记住要检查一下

```
/**
* Definition for singly-linked list.
* struct ListNode {
*    int val;
*    ListNode *next;
*    ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode * h1, *h2;
        h1 = l1;
        h2 = l2;
        // 先用一个非空的表头，降低编程复杂性
        ListNode * h = new ListNode(0);
        ListNode *p = h;
        int r = 0,val;
        while (true)
        {
            // 两个都有
            while (h1 != NULL && h2 != NULL)
            {
                val = h1->val + h2->val + r;
                r = val / 10;
                val = val % 10;
                ListNode * tmp = new ListNode(val);
                p->next = tmp;
                p = p->next;
                h1 = h1->next;
                h2 = h2->next;
            }
            while (h1 != NULL)
            {
                val = h1->val + r;
                r = val / 10;
                val = val % 10;
                ListNode * tmp = new ListNode(val);
                p->next = tmp;
                p = p->next;
                h1 = h1->next;
            }
            while (h2 != NULL)
            {
                val = h2->val + r;
                r = val / 10;
                val = val % 10;
                ListNode * tmp = new ListNode(val);
                p->next = tmp;
                p = p->next;
                h2 = h2->next;
            }
            // 最后是否有进位
            if (r != 0)
            {
                ListNode * tmp = new ListNode(r);
                p->next = tmp;
                p = p->next;
            }
            p->next = NULL;
            break;
        }
        return h->next;
    }
};
```

# 3 Longest Substring Without Repeating Characters 【类动态规划】
- 计算`f[i]`时遍历`f[i-1]`的重复区间内，是否有和`s[i]`重复的字符。其中`f[i]`代表以`i`字符结尾的字符串的最长不重复字符串

```
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if (s.size() <= 1)
            return s.size();
        vector<int> f(s.size(), 0);
        f[0] = 1;
        int maxLength = 1;
        for (int i = 1; i < s.size(); ++i)
        {
            int j;
            for ( j= i - 1; j > i - 1 - f[i-1]; --j)
            {
                if (s[i] == s[j])
                {            
                    break;
                }
            }    
            f[i] = i - j;
            if (f[i] > maxLength)
                maxLength = f[i];
        }
        return maxLength;
    }
};
```

# 4 Median of Two Sorted Arrays  【！重要的思路！】

- 思路讲解： http://blog.csdn.net/hk2291976/article/details/51107778
- 对于两个数组，我们选择一个分割点`C1`，`C2`，记左边最大的是`L`，右边最小的是`R`，则可以得到`L1`，`L2`，`R1`，`R2`
- 我们需要的是`L1< R2 && L2< R1`
- 如果不满足，移动`C1`或者`C2`，然后进行二分
- 由于需要判断奇偶数，我们对每个数组数字之间和首尾插入#，这样就可以不区别奇偶数
- 我们选择`C1`，那`C2= k-C1`，如果需要找的是第k个的时候
- 每次迭代是二分，因此总的就是`log(n)`

```
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int len1 = nums1.size();
        int len2 = nums2.size();
        if (len1 > len2)
            return findMedianSortedArrays(nums2, nums1);
        int L1, R1, L2, R2, c1, c2, Low, High;
        High = len1 * 2;
        Low = 0;
        while (Low <= High)
        {
            c1 = (Low + High) / 2;        // 对数组1进行划分
            c2 = len1 + len2 - c1;
            L1 = (c1 == 0) ? INT_MIN : nums1[(c1 - 1) / 2];        // 分别是左右的第一个数，如果划分在数字上，两者相等
            R1 = (c1 == 2 * len1) ? INT_MAX : nums1[(c1) / 2];
            L2 = (c2 == 0) ? INT_MIN : nums2[(c2 - 1) / 2];
            R2 = (c2 == 2 * len2) ? INT_MAX : nums2[(c2) / 2];
            if (L1 > R2)
            {
                High = c1-1;
            }
            else if (L2 > R1)
            {
                Low = c1+1;
            }
            else
                break;
        }
        return (max(L1, L2) + min(R1, R2)) / 2.0;
    }
};
```

# 5 Longest Palindromic Substring
1. 用一个数组记录每一个位置结尾的最长回文串
2. 计算出对称轴`axis`
3. 如果`s[i]`和轴对称的另外一个`s[]`相同，`f[i]=f[i-1]+2`
4. 否则从`axis`开始，往右移动对称轴，判断是否是回文串。

```
class Solution {
public:
    string longestPalindrome(string s) {
        if (s.size() <= 1)
            return s;
        string maxStr;
        int maxLength=1;
        vector<int> f(s.size(), 1);
        maxStr = s[0];
        for (int i = 1; i < s.size(); ++i)
        {
            float axis = (i-1-f[i-1]+1+i-1)/2.0;
            if (2 * axis - i >= 0 && s[2 * axis - i] == s[i])
            {
                f[i] = f[i - 1] + 2;
                if (f[i] > maxLength)
                {
                    maxLength = f[i];
                    maxStr = s.substr(i - f[i] + 1, f[i]);
                }
            }
            else
            {
                axis += 0.5;
                while (axis <= i)
                {
                    bool f = true;
                    for (int j = i; j >= axis; --j)
                    {
                        if (s[j] != s[2 * axis - j])
                        {
                            f = false;
                            break;
                        }
                    }
                    if (f)
                        break;
                    axis += 0.5;
                }
                f[i] = (i - axis) * 2 + 1;
                if (f[i] > maxLength)
                {
                    maxLength = f[i];
                    maxStr = s.substr(i - f[i] + 1, f[i]);
                }
            }
        }
        return maxStr;
    }
};
```

# 6 ZigZag Conversion

- 先正向往下走
- 斜向往上走
- 注意每一步判断是否已经结尾

```
class Solution {
public:
    string convert(string s, int numRows) {
        vector<string> vs(numRows);
        int len = s.size();
        bool direction = true;        //表示方向，true代表向下
        int idx=0;            // 记录总的string的index
        while (true)
        {
            if (idx >= len)
                break;
            // 正向往下走
            if (direction)
            {
                for (int i = 0; i < numRows; i++)
                {
                    if (idx < len)
                        vs[i] += s[idx++];
                    else
                        break;
                }
                direction = !direction;
            }
            // 斜向往上走
            else
            {
                for (int i = numRows - 2; i > 0; i--)
                {
                    if (idx < len)
                        vs[i] += s[idx++];
                    else
                        break;
                }
                direction = !direction;
            }
        }
        // 合并字符串
        string str;
        for (int i = 0; i < numRows; i++)
            str += vs[i];
        return str;
    }
};

```

# 7 Reverse Integer
- 注意符号和溢出
- 使用`long long`即可解决

```
class Solution {
public:
    int reverse(int x) {
        long long num = x;
        bool f = true;
        if (num < 0)
        {
            num = -num;
            f = false;
        }    
        long long number = 0;
        while (num)
        {
            number *= 10;
            number += num % 10;
            num /= 10;
        }
        if (!f)
            number = -number;
        if (number > INT_MAX)
            number = 0;
        if (number < INT_MIN)
            number = 0;
        return number;
    }
};
```

# 8 String to Integer (atoi) 【细节多】

- 使用`long long`防止溢出
- 前面的空格
- 符号位
- **遇到非数字结束转换，以前面的为准**
- 注意`int`的边界值

**一些示例输入**
```
Input                 Output        Expected
"    b11228552307"    2147483647    0
"+-2"                 2            0
"  -0012a42"         0            -12
"   +0 123"             123        0
" 10522545459"         1932610867    2147483647
```

**代码**

```
class Solution {
public:
    int myAtoi(string str) {
        int len = str.size();
        // 使用long long 防止溢出
        long long tmp =0;
        bool f = true;
        int i = 0;
        // 去掉前面的空格
        while (str[i] == ' ')
            i++;
        // 如果有符号位
        if (str[i] == '-')
        {
            f = false;
            i++;
        }
        else
        {
            if (str[i] == '+')
            {
                f = true;
                i++;
            }
            else if (str[i] > '9' || str[i] < '0')
                return tmp;
        }
        for (; i < len; i++)
        {
            int data = (str[i] - '0');
            // 遇到一个非数字，不往下搜索，以前面得到的数字为准
            if (data < 0 || data >= 10)
            {
                break;
            }
            tmp *= 10;
            tmp += data;
            // 判断int 的边界值
            if (f)
            {
                if (tmp > 2147483647)
                {
                    tmp = 2147483647;
                    break;
                }
            }
            else
            {
                if (tmp >= 2147483648)
                {
                    tmp = 2147483648;
                    break;
                }
            }            
        }
        if (f)
            return tmp;
        return -tmp;
    }
};
```

# 9 Palindrome Number 【考虑溢出】
- 转化成`long long`
- 逆序，比较是否相等

```
class Solution {
public:
    bool isPalindrome(int x) {
        long long num = x;
        if (num < 0)
            return false;
        long long num2 =0;
        while (num)
        {
            num2 *= 10;
            num2 += num % 10;
            num /= 10;
        }
        num = x;
        if (num == num2)
            return true;
        return false;
    }
};
```

# 10 Regular Expression Matching 【动态规划】

## 自己的解法
- 类似于动态规划，使用记忆化的数组，防止重复的搜索
- 具体的业务细节见代码，逻辑略复杂

```
class Solution {
public:
    int ** f;       // 使用一个记录数组，防止重复的递归

    bool solve(int idx1,int idx2,string s, string p)
    {
        if (idx1 == s.size())
        {
            if (idx2 == p.size())
                return true;
            else
            {
                bool f1 = true;
                bool f2 = true;
                // 对应于s已经匹配玩，p没有匹配完的，必须是* 结尾，必须隔一个是*
                for (int i = idx2+1; i < p.size(); i = i + 2)
                {
                    if (p[i] != '*')
                    {
                        f1 = false;
                        break;
                    }
                }
                for (int i = idx2; i < p.size(); i = i + 2)
                {
                    if (p[i] != '*')
                    {
                        f2 = false;
                        break;
                    }
                }
                if (p[p.size() - 1] != '*')
                    return false;
                return f1 || f2;
            }            
        }            
        if (idx2 == p.size())
            return false;
        // 返回
        if (f[idx1][idx2] != -1)
            return f[idx1][idx2];
        char c1 = s[idx1];
        char c2 = p[idx2];
        // 如果两个相等，都往后推进
        if (c1 == c2 || c2=='.')
        {
            bool f1 = solve(idx1 + 1, idx2 + 1, s, p);
            bool f2 = solve(idx1, idx2 + 2, s, p);
            // 后面是* 的话  可以选择跨越或者都往前进一格
            if (idx2 < p.size() - 1 && p[idx2 + 1] == '*')
            {
                f[idx1][idx2] = f1 || f2;
                return f1 || f2;
            }            
            else
            {
                f[idx1][idx2] = f1;
                return f1;
            }            
        }
        else
        {        
            // 如果等于*，看前一个是否相等，并且可以选择指针移动或者不移动
            if (c2 == '*')
            {
                bool f1 = solve(idx1 + 1, idx2 + 1, s, p);      
                bool f2 = solve(idx1 + 1, idx2, s, p);
                bool f3 = solve(idx1, idx2 + 1, s, p);
                if (idx2 >= 1 && (p[idx2 - 1] == '.' || p[idx2 - 1] == c1))
                {
                    f[idx1][idx2] = f1 || f2 || f3;  // f1 前面的相同，共同推进，f2 由于.的存在，直接s后推，f3 *对应于前一个字符的，p后推
                    return f1 || f2 || f3;
                }
                f[idx1][idx2] = f3;
                return f3;
                //return solve(idx1, idx2 + 1, s, p);
            }
            else
            {
                bool f1 = solve(idx1, idx2 + 2, s, p);          // 后面跟了个* 直接s推进两格   
                // 不同，但是后面跟了*
                if (idx2 < p.size() - 1 && p[idx2+1]=='*')
                {
                    f[idx1][idx2] = f1;
                    return f1;
                }
            }
        }
        f[idx1][idx2] = 0;
        return false;
    }

    bool isMatch(string s, string p) {
        int len1 = s.size();
        int len2 = p.size();
        int idx1 = 0;
        int idx2 = 0;
        f = new int *[len1];
        for (int i = 0; i < len1; i++)
        {
            f[i] = new int[len2];
            memset(f[i], -1, sizeof(int)*len2);
        }        
        return solve(idx1, idx2, s, p);
    }

};
```
## 别人的解法一  回溯，递归调用
- **从后往前匹配**  不需要判断后面一个是否是*

```
class Solution {
public:
    static const int FRONT=-1;
    bool isMatch(string s, string p) {
        return myMatch(s,s.length()-1,p,p.length()-1);
    }
    bool myMatch(string s, int i, string p,int j)
    {
        if(j == FRONT)
            if(i == FRONT)    return true;
        else return false;
// 遇到的是*
        if(p[j] == '*')
        {
            if(i > FRONT && (p[j-1] == '.' || p[j-1] == s[i]))
                if(myMatch(s,i-1,p,j))
                    return true;
            return myMatch(s,i,p,j-2);
        }
// 遇到不是*
        if(p[j] == '.' || p[j] == s[i])
            return myMatch(s,i-1,p,j-1);
        return false;
    }
};
```
## 别人的解法二 动态规划，使用数组

- `dp[i][j]`的含义是`s[0-i]`与`s[0-j]`是否匹配
- 转移方程

```
p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1]

If p.charAt(j) == ‘.’ : dp[i][j] = dp[i-1][j-1];

If p.charAt(j) == ‘*’: 
here are two sub conditions: 
if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2] //in this case, a* only counts as empty
if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == ‘.’:
dp[i][j] = dp[i-1][j] //in this case, a* counts as multiple a
dp[i][j] = dp[i][j-1] // in this case, a* counts as single a
dp[i][j] = dp[i][j-2] // in this case, a* counts as empty
```
- 初始化数组
```
dp[0][0] = true;
//初始化第0行,除了[0][0]全为false，毋庸置疑，因为空串p只能匹配空串，其他都无能匹配
for (int i = 1; i <= m; i++) 
    dp[i][0] = false; 
//初始化第0列，只有X*能匹配空串，如果有*，它的真值一定和p[0][j-2]的相同（略过它之前的符号）
for (int j = 1; j <= n; j++) 
    dp[0][j] = j > 1 && '*' == p[j - 1] && dp[0][j - 2];
```

- 完整代码
```
class Solution
{
public:
    static const int FRONT=-1;
    bool isMatch(string s, string p)
    {
        int m = s.length(),n = p.length();
        bool dp[m+1][n+1];
        dp[0][0] = true;
//初始化第0行,除了[0][0]全为false，毋庸置疑，因为空串p只能匹配空串，其他都无能匹配
        for (int i = 1; i <= m; i++)
            dp[i][0] = false;
//初始化第0列，只有X*能匹配空串，如果有*，它的真值一定和p[0][j-2]的相同（略过它之前的符号）
        for (int j = 1; j <= n; j++)
            dp[0][j] = j > 1 && '*' == p[j - 1] && dp[0][j - 2];

        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                if (p[j - 1] == '*')
                {
                    dp[i][j] = dp[i][j - 2] || (s[i - 1] == p[j - 2] || p[j - 2] == '.') && dp[i - 1][j];

                }
                else  //只有当前字符完全匹配，才有资格传递dp[i-1][j-1] 真值
                {
                    dp[i][j] = (p[j - 1] == '.' || s[i - 1] == p[j - 1]) && dp[i - 1][j - 1];

                }
            }
        }
        return dp[m][n];
    }
};
```

# 11 Container With Most Water

- 如果完全遍历，需要`n^2`的复杂度
- 扫描一遍，从两边往中间扫描
- 不等时移动较小的边，相等时移动到较大的边

```
class Solution {
public:
    int maxArea(vector<int>& height) {
        int len = height.size();
        int sum = 0;
        int l = 0,r = len - 1;
        while (l < r)
        {
            int s = min(height[r], height[l])*(r-l);
            sum = max(s, sum);
            // 选择移动较小的一个边
            if (height[r] < height[l])
            {
                r--;
            }
            else if (height[r]>height[l])
            {
                l++;
            }
            // 相等，选择移动到较大的一个边
            else
            {
                if (height[r - 1]>height[l + 1])
                {
                    r--;
                }
                else
                {
                    l++;
                }
            }
        }
        return sum;
    }
};
```

# 12 Integer to Roman

1. `I`(1),`V`(5),`X`(10),`L`(50),`C`(100),`D`(500),`M`(1000)
2. 左减右加
3. 左减`I`,`X`,`C`
4. 左减不得跨位，不超过一位
5. 右加不超过三位
6. 测试范围`1-3999`

```
class Solution {
public:
    string intToRoman(int num) {
        vector<vector<char> > f;
        f.push_back({'I','V','X'});
        f.push_back({ 'X', 'L', 'C' });
        f.push_back({ 'C', 'D', 'M' });
        f.push_back({ 'M' });
        int idx = 0;
        string s;
        while (num)
        {
            int c = num % 10;
            num /= 10;
            switch (c)
            {
            case 0: break;
            case 1: s += f[idx][0]; break;
            case 2: s += f[idx][0]; s += f[idx][0]; break;
            case 3: s += f[idx][0]; s += f[idx][0]; s += f[idx][0]; break;
            case 4: s += f[idx][1]; s += f[idx][0]; break;
            case 5: s += f[idx][1]; break;
            case 6: s += f[idx][0]; s += f[idx][1]; break;
            case 7: s += f[idx][0]; s += f[idx][0]; s += f[idx][1]; break;
            case 8: s += f[idx][0]; s += f[idx][0]; s += f[idx][0]; s += f[idx][1]; break;
            case 9: s += f[idx][2]; s += f[idx][0]; break;
            default:
                break;
            }        
            ++idx;
            if (idx == 3)        // 千位的特殊情况
            {
                c = num % 10;
                switch (c)
                {
                case 0: break;
                case 1: s += f[idx][0]; break;
                case 2: s += f[idx][0]; s += f[idx][0]; break;
                case 3: s += f[idx][0]; s += f[idx][0]; s += f[idx][0]; break;            
                default:
                    break;
                }
                break;
            }
        }
        reverse(s.begin(), s.end());
        return s;
    }
};
```

# 13 Roman to Integer
- 记录上一位，如果上一位小于这一位，是左减，需要减两次（因为前面加过一次）
- 否则直接累加即可

```
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int> priority;
        priority['I'] = 1;
        priority['V'] = 5;
        priority['X'] = 10;
        priority['L'] = 50;
        priority['C'] = 100;
        priority['D'] = 500;
        priority['M'] = 1000;
        int sum =priority[s[0]];
        int last_v = priority[s[0]];
        for (int i = 1; i < s.size(); ++i)
        {
            // 前一位小于后一位，则进行减操作，之前加过一次，因此减两次
            if (priority[s[i - 1]] < priority[s[i]])
            {
                sum += priority[s[i]];
                sum -= last_v;
                sum -= last_v;
            }
            else
            {
                sum += priority[s[i]];
            }
            last_v = priority[s[i]];
        }
        return sum;
    }
};
```

# 14 Longest Common Prefix
- 最长的公共前缀

```
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        string s;
        if (strs.size() == 0)
            return s;
        int minLen = INT_MAX;
        for (int i = 0; i < strs.size(); i++)
        {
            if (strs[i].size() < minLen)
                minLen = strs[i].size();
        }
        for (int i = 0; i < minLen; i++)
        {
            int c = strs[0][i];
            for (int j = 0; j < strs.size(); j++)
            {
                if (strs[j][i] != c)
                    return s;
            }
            s += c;
        }
        return s;
    }
};
```

# 15 3sum
- 先进行排序
- 控制一个数，然后得到头尾指针，分别向中间移动
- 使用`set`进行判重

```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int len = nums.size();
        vector<vector<int> >  vvi;
        set<vector<int> > svi;    
        for (int i = 0; i < len - 2; i++)
        {
            // 确定一个数后从前后开始搜索
            int begin = i + 1;
            int end = len - 1;
            while (begin < end)
            {
                if (nums[i] + nums[begin] + nums[end] == 0)
                {
                    vector<int> vi;
                    vi.push_back(nums[i]);
                    vi.push_back(nums[begin]);
                    vi.push_back(nums[end]);
                    svi.insert(vi);
                    // 移动前后指针
                    begin++;
                    end--;
                }
                else if (nums[i] + nums[begin] + nums[end] < 0)
                {
                    begin++;
                }
                else
                {
                    end--;
                }
            }
        }
        // 复制到vector
        for (set<vector<int> > ::iterator it = svi.begin(); it != svi.end(); it++)
        {
            vvi.push_back(*it);
        }    
        return vvi;
    }
};
```

# 16 3Sum Closest
- 主体思路同15题
- 不需要判重，只需要记录最短距离和最短距离时的和即可

```
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        int len = nums.size();
        int Min = INT_MAX;
        int MinVal=0;
        for (int i = 0; i < len - 2; i++)
        {
            int begin = i + 1;
            int end = len - 1;
            while (begin < end)
            {
                int v = nums[i] + nums[begin] + nums[end];
                if ( v== target)
                {
                    return target;
                }
                else if (v-target<0)
                {
                    if (abs(v- target) < Min)
                    {
                        Min = abs(v - target);
                        MinVal = v;
                    }
                    begin++;
                }
                else
                {
                    if (abs(v- target) < Min)
                    {
                        Min = abs(v - target);
                        MinVal = v;
                    }
                    end--;
                }
            }
        }
        return MinVal;
    }
};
```

# 17 Letter Combinations of a Phone Number

## 解法一
- 递归搜索

```
class Solution {
public:
    void solve(int idx, string digits, vector<string>& pattern, vector<string>& vs,string &s)
    {
        if (idx == digits.size())
        {
            vs.push_back(s);
            return;
        }
        int c = digits[idx] - '0';
        for (int i = 0; i < pattern[c].size(); ++i)
        {
            s.push_back(pattern[c][i]);
            solve(idx + 1, digits, pattern, vs, s);
            s.pop_back();
        }
    }

    vector<string> letterCombinations(string digits) {
        vector<string> pattern;
        vector<string> vs;
        if (digits.size() == 0)
            return vs;
        string s;
        pattern.push_back("");
        pattern.push_back("");//1
        pattern.push_back("abc");
        pattern.push_back("def");
        pattern.push_back("ghi");
        pattern.push_back("jkl");
        pattern.push_back("mno");
        pattern.push_back("pqrs");
        pattern.push_back("tuv");
        pattern.push_back("wxyz");
        solve(0, digits, pattern, vs,s);
        return vs;
    }
};
```

## 解法二 循环
- 详见编程之美

```
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        vector<string> pattern;
        vector<string> vs;
        if (digits.size() == 0)
            return vs;
        string s;
        pattern.push_back("");
        pattern.push_back("");//1
        pattern.push_back("abc");
        pattern.push_back("def");
        pattern.push_back("ghi");
        pattern.push_back("jkl");
        pattern.push_back("mno");
        pattern.push_back("pqrs");
        pattern.push_back("tuv");
        pattern.push_back("wxyz");
        int idxCnt[10] = { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 };
        vector<int> index(digits.size(), 0);        // 循环变量，第i个字符在i个字符串中的位置
        while (true)
        {
            s.clear();
            for (int i = 0; i < digits.size(); ++i)
            {
                s += pattern[digits[i] - '0'][index[i]];
            }            
            vs.push_back(s);

            int j = 0;
            while (j<digits.size())
            {
                if (index[j] < idxCnt[digits[j] - '0']-1)        // 注意是减一
                {
                    index[j]++;
                    break;
                }
                else
                {
                    index[j] = 0;        // 进入下一层循环
                    ++j;
                }
            }
            if (j >= digits.size())        // 循环到最外一层
                break;
        }
        return vs;
    }

};
```

# 18 4sum

- 选择两个数建立一个`map`，`map`的`key`是和，值是该值下的`pair`队列
- 任意遍历两个数，检查是否有`target-a-b`的key
- 使用`set`进行去重
- 注意可能会有相同的值，需要防止相同的`pair`选择两遍

```
class Solution {
public:
    // 判断某一个序列是否是其中的一个子集
    bool ifContainer(vector<int> nums, vector<int> tmp)
    {
        vector<int> vf(nums.size(), 0);
        bool f = true;
        for (int j = 0; j < 4; j++)
        {
            bool ok = false;
            for (int k = 0; k < nums.size(); k++)
            {
                if (tmp[j] == nums[k] && vf[k] == 0)
                {
                    ok = true;
                    vf[k] = 1;
                    break;
                }
            }
            if (!ok)
            {
                f = false;
                break;
            }
        }
        return f;
    }

    vector<vector<int> > fourSum(vector<int>& nums, int target) {
        map<int,vector<pair<int,int> > > mp;
        sort(nums.begin(), nums.end());
        int len = nums.size();
        vector<vector<int> >  vvi;
        // 建立每两个数的map，map的key是和，值是该值下的pair队列
        for (int i = 0; i < len-1; i++)
        {
            for (int j = i + 1; j < len; j++)
            {        
                int v = nums[i] + nums[j];
                pair<int,int> p;
                p = make_pair(nums[i], nums[j]);
                mp[v].push_back(p);
            }
        }
        for (int i = 0; i < len - 1; i++)
        {
            for (int j = i + 1; j < len; j++)
            {
                int v = nums[i] + nums[j];
                v = target - v;
                vector<pair<int, int> > vp = mp[v];            
                if (vp.size() > 0)
                {
                    // 防止一半时将自己算入其中
                    if (v == target / 2)
                    {
                        if (vp.size() == 1)
                            continue;
                        // 如果确实有多个相同的，仅算一个
                        bool tag = true;
                        for (int k = 0; k < vp.size(); k++)
                        {
                            pair<int, int> p = vp[k];
                            if (p==make_pair(nums[i],nums[j]) && tag)
                            {
                                tag = false;
                                continue;
                            }                                
                            vector<int> vi;
                            vi.push_back(nums[i]);
                            vi.push_back(nums[j]);
                            vi.push_back(p.first);
                            vi.push_back(p.second);
                            sort(vi.begin(), vi.end());
                            vvi.push_back(vi);
                        }
                    }
                    else
                    {
                        for (int k = 0; k < vp.size(); k++)
                        {
                            pair<int, int> p = vp[k];
                            vector<int> vi;
                            vi.push_back(nums[i]);
                            vi.push_back(nums[j]);
                            vi.push_back(p.first);
                            vi.push_back(p.second);
                            sort(vi.begin(), vi.end());
                            vvi.push_back(vi);
                        }
                    }                
                }
            }
        }
        // 使用set进行去重
        set<vector<int> > svi;
        for (int i = 0; i < vvi.size(); i++)
            svi.insert(vvi[i]);
        vvi.clear();
        for (set<vector<int> > ::iterator it = svi.begin(); it != svi.end(); it++)
        {
            vector<int> tmp = *it;
            if (ifContainer(nums,tmp))
                vvi.push_back(*it);
        }        
        return vvi;
    }
};
```

- 更快速的方法
- 先进行排序
- 遍历`a,b,`通过类似2sum的那种方法，对`c,d,`进行移动操作
- 然后将结果存入到`set`中
- **核心是排序后，控制两个sum，也就转化为了2sum的问题，因为可能会带来重复，需要用set进行存储。**

```
class Solution {
public:
    vector<vector<int> > fourSum(vector<int> &num, int target) {
        vector<vector<int>> out;
        set<vector<int>> res;
        if (num.size() < 4)
            return out;
        sort(num.begin(), num.end());
        for (int i=0; i<num.size()-3; i++)
        {
            
            for (int j =i+1;j<num.size()-2;j++)
            {
                int begin = j+1;
                int end = num.size()-1;
// 控制了2sum的值，然后再剩下的序列中进行2sum的操作
                while(begin < end){
                    int sum = num[i] + num[j] + num[begin] + num[end];
                    if (sum== target)
                    {
                        vector<int> tmp;
                        tmp.push_back(num[i]);
                        tmp.push_back(num[j]);
                        tmp.push_back(num[begin]);
                        tmp.push_back(num[end]);
                        res.insert(tmp);
                        begin++;
                        end--;
                    } 
                    else if(sum < target)
                    {
                        begin++;
                    }else{
                        end--;
                    }
                }
                
            }
        }
        set<vector<int>>::iterator it = res.begin();  
        for(; it != res.end(); it++)  
            out.push_back(*it); 


    }
};
```

# 19 Remove Nth Node From End of List 【链表】

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        vector<ListNode *> vl;    
        // 生成一个自定义的头部和尾部节点
        ListNode * h = new ListNode(20);
        ListNode * r = NULL;    //尾部节点定义为空
        vl.push_back(h);
        vl[0]->next = head;
        while (head)
        {
            vl.push_back(head);
            head = head->next;
        }
        vl[vl.size() - 1]->next = r;
        vl.push_back(r);
        int len = vl.size();
        // 删除节点
        vl[len - n - 2]->next = vl[len - n];
        // 将尾部节点的next删除，如果删除的本身是尾部节点，将接到自定义的尾部节点，因此需要定义尾部节点为空
        vl[len - 2]->next = NULL;
        return vl[0]->next;
    }
};
```

# 20 Valid Parentheses 【栈】
- 使用`si.top()`注意先判断是否为空

```
class Solution {
public:
    bool isValid(string s) {
        stack<int> si;
        bool f = true;
        for (int i = 0; i < s.size(); i++)
        {
            if (s[i] == '(')
                si.push(')');
            else if (s[i] == '{')
                si.push('}');
            else if (s[i] == '[')
                si.push(']');
            else
            {
                if (si.empty())
                {
                    f = false;
                    break;
                }
                if (si.top() != s[i])
                {
                    f = false;
                    break;
                }
                si.pop();
            }
        }
        if (!si.empty())
            f = false;
        return f;
    }
};
```

# 21 Merge Two Sorted Lists 【链表】

- 注意尾指针
- 使用一个自定义的头指针
- 访问指针前先判断是否为空

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode * h = new ListNode(0);
        ListNode * p = h;
        while (l1 || l2)
        {
            while (l1 && l2)
            {
                if (l1->val < l2->val)
                {
                    p->next = l1;
                    p = p->next;
                    l1 = l1->next;
                }
                else
                {
                    p->next = l2;
                    p = p->next;
                    l2 = l2->next;
                }
            }
            while (l1)
            {
                p->next = l1;
                p = p->next;
                l1 = l1->next;
            }
            while (l2)
            {
                p->next = l2;
                p = p->next;
                l2 = l2->next;
            }
        }
        // 注意尾指针
        p->next = NULL;
        return h->next;
    }
};
```

# 22 Generate Parentheses 【回溯法搜索】

- 搜索

```
class Solution {
public:
    vector<string> vs;
    string s;
    stack<int> si;
    void solve(int idx,int cnt, int n)
    {
        if (idx == 2*n)
        {
            vs.push_back(s);
            return;
        }    
        // 记录'(' 的次数
        if (cnt < n)        
        {
            s.push_back('(');
            si.push(')');
            solve(idx + 1,cnt+1, n);
            s.pop_back();
            si.pop();
        }    
        // 如果可以弹出
        if (!si.empty())
        {
            s.push_back(')');
            si.pop();
            solve(idx + 1,cnt, n);
            si.push(')');
            s.pop_back();
        }    
    }

    vector<string> generateParenthesis(int n) {
        vs.clear();
        s.clear();
        while (!si.empty())
            si.pop();
        solve(0, 0,n);
        return vs;
    }
};
```

# 23 Merge k Sorted Lists
- 需要保存一个固定大小的保持排序的数据结构，以`O(1)`获得最小值
- 可以选用`BST`，`AVL`，堆，标准库的集合，哈希等，这些都是维持排序的
- 由于可能有重复值，需要使用可以容纳重复值的容器
- 复杂度`O(n*logk)`

```
/**
* Definition for singly-linked list.
* struct ListNode {
*    int val;
*    ListNode *next;
*    ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        using PointX = pair<ListNode *, int>;
        auto f = [](const PointX &p1, const PointX &p2) ->bool{ return p1.second < p2.second; };
        ListNode * head = new ListNode(0);
        ListNode * tmp = head;
        // 允许重复值的集合
        multiset<PointX, bool(*)(const PointX &, const PointX &)> pSet(f);

        for (int i = 0; i < lists.size(); ++i)
        {
            if (lists[i])
            {
                pSet.insert(PointX(lists[i], lists[i]->val));
            }
        }

        while (pSet.size() > 0)
        {
            auto p = *(pSet.begin());
            tmp->next = p.first;
            tmp = tmp->next;

            pSet.erase(pSet.begin());      // 不能删除值，会把重复的全部删除，删除对应的迭代器
            if (p.first->next)
                pSet.insert(PointX(p.first->next, p.first->next->val));
        }
        // 尾指针置空
        tmp->next = nullptr;
        return head->next;    
    }
};
```

# 24 Swap Nodes in Pairs 【链表】

- 交换链表相邻值

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode * h = head;
        while (h && h->next)  // 一次判断到位
        {
            int v = h->val;
            h->val = h->next->val;
            h->next->val = v;
            h = h->next->next;
        }
        return head;
    }
};
```

# 25 Reverse Nodes in k-Group 【链表】

- 使用一个头节点，便于头节点操作
- 注意链表的尾部节点，防止出现环或者没有尾巴

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if (k == 0)
            return head;
        // 使用一个头指针
        ListNode * h = new ListNode(0);
        h->next = head;
        ListNode * p = h;
        vector<ListNode *> vl(k);
        while (head)
        {
            int cnt = 0;
            while (cnt < k && head)
            {
                vl[cnt++] = head;
                head = head->next;        
            }
            if (cnt < k)
                break;
            // 将这个单元的最后一个指针的next存取起来
            ListNode * tmp = vl[cnt - 1]->next;
            for (int i = cnt - 1; i >= 0; i--)
            {
                p->next = vl[i];
                p = p->next;            
            }
            // 复原指针尾巴
            p->next = tmp;
        }

        return h->next;
    }
};
```

## 翻转单链表的三种方法 【重要】

1. 重新插入一遍，每次从头部插入
2. 记录一个头部节点和初始位置，每次将初始位置后的节点翻转到头部，向前移动头节点
3. 记录一个头部节点和初始位置，不断将头部节点翻转到初始位置的后面，向后移动头节点 【2.3 方法类似】

# 26 Remove Duplicates from Sorted Array【线性空间删除数组重复值】
- 两个指针：一个指向删除重复后的最后一个，一个指向原数组

```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.size() <= 1)
            return nums.size();
        int l1 = 0;        // 数组指针
        int cnt = 1;    // 计数
        for (int i = 1; i < nums.size(); ++i)
        {
            if (nums[i] != nums[l1])
            {
                nums[++l1] = nums[i];
                ++cnt;
            }
        }
        return cnt;
    }
};
```

# 27 Remove Element

- 线性空间，在自身复制

```
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int cnt = 0;        // val的个数
        int idx1 = 0;       // 记录返回的有效位置
        int idx2 = 0;       // 移动的指针
        while (idx2 < nums.size())
        {
            if (nums[idx2] == val)
            {
                idx2++;
                cnt++;
            }
            else
            {
                nums[idx1] = nums[idx2];
                idx1++;
                idx2++;
            }
        }
        return nums.size() - cnt;
    }
};
```

# 28 Implement strStr()

```
class Solution {
public:
    int strStr(string haystack, string needle) {
        int len1 = haystack.size();
        int len2 = needle.size();
        if(len1 ==0 && len2==0)
            return 0;
        if (len1 < len2)
            return -1;
        for (int i = 0; i <= len1 - len2; i++)
        {
            string s = haystack.substr(i, len2);
            if (s == needle)
                return i;
        }
        return -1;
    }
};
```

# 29 Divide Two Integers 【数值计算，重要】

- 由于不能使用乘除，取余数，因此可以使用的是加减法和移位操作
- 一个整数可以这样表示：`num=a_0*2^0+a_1*2^1+a_2*2^2+...+a_n*2^n`
- 我们先得到一个最大的不大于`num`的`a_0`的倍数，每次扩大两倍（移1位）
- 然后记录移动的位数，每次来减，记录总体的倍数即可
- 注意`int`的极限值，负值比正值多一位，注意区分正负，使用`long long`来记录防止越界

## 自己的代码，不知道为啥没通过

```
int divide(int dividend, int divisor) {
    // 除数为0 直接返回max
    if (divisor == 0)
        return INT_MIN;
    // 被除数为0 返回0
    if (dividend == 0)
        return 0;
    // 判断正负
    bool f = false;
    if ((dividend > 0) && (divisor > 0) || (dividend < 0) && (divisor < 0))
        f = true;
    // 使用long long 防止越界
    long long d1, d2;
    if (dividend == INT_MIN)
    {
        if (f)            // 如果同号的就得加一，int 负数表达范围会大一个
            d1 = abs(dividend + 1);
        else
            d1 = abs((long long)dividend);  // 如果结果是负的，就不能丢失精度
    }        
    else
        d1 = abs(dividend);
    // 
    if (divisor == INT_MIN)
    {
        if (f)
            d2 = abs(divisor + 1);
        else
            d2 = abs((long long)divisor);
    }        
    else
        d2 = abs(divisor);    
    if (d1 < d2)
        return 0;
    if (d1 == d2)
    {
        if (f)
            return 1;
        return -1;
    }        
    int k=0;
    int cnt=0;
    long long d = d2;
    // 找到不大于d1的最大
    while (d < d1)
    {
        d =d<<1;    //每次扩大2倍
        k++;        
    }
    d >>= 1;
    k--;
    while (d1)
    {
        if (d1 >= d)    //如果可以减，需要增加1<<k个
        {
            d1 -= d;
            cnt += (1 << k);            
        }
        else // 如果没法减，必须减小两倍
        {
            d >>= 1;
            k--;            
            if (d < d2)
                break;
        }        
    }
    if (f)
        return cnt;
    return -cnt;
}
```

## 别人的代码通过
```
class Solution {
public:
    int divide(int dividend, int divisor) {
        long long m = abs((long long)dividend), n = abs((long long)divisor), res = 0;
        if (m < n) return 0;    
        while (m >= n) {
            long long t = n, p = 1;
            while (m > (t << 1)) { // 每次找到最接近的不大于的n的倍数，注意判断时的技巧
                t <<= 1;
                p <<= 1;
            }
            res += p;
            m -= t;
        }
        // 判断符号
        if ((dividend < 0) ^ (divisor < 0)) res = -res;
        // 防止溢出
        return res > INT_MAX ? INT_MAX : res;
    }
};
```

## 递归写法
```
class Solution {
public:
    int divide(int dividend, int divisor) {
        long long res = 0;
        long long m = abs((long long)dividend), n = abs((long long)divisor);
        if (m < n) return 0;
        long long t = n, p = 1;
        while (m > (t << 1)) {
            t <<= 1;
            p <<= 1;
        }
        res += p + divide(m - t, n);
        if ((dividend < 0) ^ (divisor < 0)) res = -res;
        return res > INT_MAX ? INT_MAX : res;
    }
};
```

# 34 Search for a Range 【二分法】

- 两遍二分法
- 分别找到最左边一个和最右边一个
- 注意判断0和1的极端情况

```
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int len = nums.size();
        vector<int> v(2);
        v[0] = -1;
        v[1] = -1;
        // 一个和两个的极端情况
        if (len == 0)
            return v;
        if (len == 1)
        {
            if (target == nums[0])
            {
                v[0] = 0;
                v[1] = 0;
            }        
            return v;
        }    
        int l = -1;
        int r = len;
        int idx1 = -1,idx2 =-1;
        // 找到大于等于的最右一个
        while (l+1!= r)
        {
            int i = (l + r) / 2;
            if (target < nums[i])
            {
                r = i;
            }
            else
            {
                l = i;
            }
        }    
        if (nums[l] != target)
            return v;
        idx2 = l;
        l = -1;
        r = len;
        // 找到小于等于的最左边一个
        while (l + 1 != r)
        {
            int i = (l + r) / 2;
            if (target <= nums[i])
            {
                r = i;
            }
            else
            {
                l = i;
            }
        }
        idx1 = r;
        v[0] = idx1;
        v[1] = idx2;
        return v;
    }
};
```

# 35 Search Insert Position 【二分法】

- 标准的二分法，已经排序的数组
- 先将两个指针分别放在索引外围，一个-1，一个$nums.size()$
- 两个相差1即停止
- 区别找到一个合适位置或者找到最前一个

```
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int l = -1;
        int r = nums.size();
        while (l != r - 1)
        {
            int mid = (l + r) / 2;
            if (nums[mid] < target)
                l = mid;
            else
                r = mid;
        }
        return r;
    }
};
```


# 36 Valid Sudoku
- 是否为有效的数独
- 不是搜索状态空间，直接判断当前的情况
- 分为三种情况，详见代码

```
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        // 当作三种遍历，一种是固定行，遍历列，一种是固定列，遍历行，还有一种是固定正方形的编号，遍历正方形内的编号
        for (int i = 0; i < 9; i++)
        {
            // 分别对应于三种情况
            unordered_map<int, bool> m1;    
            unordered_map<int, bool> m2;
            unordered_map<int, bool> m3;

            for (int j = 0; j < 9; j++)
            {
                // 固定行，遍历列
                if (board[i][j] != '.')
                {
                    if (m1[board[i][j]] == true)
                        return false;
                    m1[board[i][j]] = true;
                }
                // 固定列，遍历行
                if (board[j][i] != '.')
                {
                    if (m2[board[j][i]] == true)
                        return false;
                    m2[board[j][i]] = true;
                }
                // 第i个正方形的第j个格子  分别求出对应的行列号
                if (board[i / 3 * 3 + j / 3][i % 3 * 3 + j % 3] != '.')
                {
                    if (m3[board[i / 3 * 3 + j / 3][i % 3 * 3 + j % 3]] == true)
                        return false;
                    m3[board[i / 3 * 3 + j / 3][i % 3 * 3 + j % 3]] = true;
                }
            }
        }
        return true;
    }
};
```

# 37 Sudoku Solver 【九宫格算法】
- 按照行搜索
- 先检测该点是否符合，符合的话进行往下继续搜索，记住如果不符合需要改回原来的$.$标识
- 需要检测行是否矛盾，列是否矛盾，所在格子是否矛盾

```
class Solution {
public:
    // 检测这个位置是否不符合要求
    bool isValid(vector<vector<char> > &board, int x, int y)
    {
        int i, j;
        // 每一行
        for (i = 0; i < 9; i++)
            if (i != x && board[i][y] == board[x][y])
                return false;
        // 每一列
        for (j = 0; j < 9; j++)
            if (j != y && board[x][j] == board[x][y])
                return false;
        // 每一个九宫格
        for (i = 3 * (x / 3); i < 3 * (x / 3 + 1); i++)
            for (j = 3 * (y / 3); j < 3 * (y / 3 + 1); j++)
                if (i != x && j != y && board[i][j] == board[x][y])
                    return false;
        return true;
    }

    // 从哪一行开始继续搜索，减小部分复杂度
    bool solve(vector<vector<char>>& board,int idx)
    {
        for (int i = idx; i < 9; ++i)   // 一行一行搜索的
            for (int j = 0; j < 9; ++j)
            {
                if ('.' == board[i][j])
                {
                    for (int k = 1; k <= 9; ++k)
                    {
                        board[i][j] = '0' + k;
                        // 从这个位置开始搜索
                        if (isValid(board, i, j) && solve(board,i))
                            return true;
                        board[i][j] = '.';
                    }
                    return false;
                }
            }
        return true;
    }

    void solveSudoku(vector<vector<char>>& board)
    {
        solve(board, 0);
    }
};
```


# 42 Trapping Rain Water

- 找到最大位置
- 从左往右
- 从右往左

```
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.size()<=1)
            return 0;
        int maxHeight = -1;
        int sum = 0;
        int idx=-1;
        // 找到最大值的位置
        for (int i = 0; i < height.size(); i++)
        {
            if (height[i] > maxHeight)
            {
                maxHeight = height[i];
                idx = i;
            }            
        }
        // 从左往右
        int maxh = height[0];
        for (int i = 0; i < idx; i++)
        {
            if (maxh >= height[i])
            {
                sum += maxh - height[i];
            }
            else
            {
                maxh = height[i];
            }
        }
        // 从右往左
        maxh = height[height.size() - 1];
        for (int i = height.size() - 1; i > idx; i--)
        {
            if (maxh >= height[i])
            {
                sum += maxh - height[i];
            }
            else
            {
                maxh = height[i];
            }
        }
        return sum;
    }
};
```

# 45 Jump Game II

- 遍历数组，到达该位置的步数等于能到达这个位置的最小的一个前值+1
- 因此只需要记录上一次到达的最小位置
- 然后从这个位置开始搜索，递增，满足的第一个就记录下来
- 不然会超时

```
class Solution {
public:
    int jump(vector<int>& nums) {
        vector<int> minDis(nums.size(), 0);
        int idx = 0;
        for (int i = 1; i < nums.size(); i++)
        {
            int v=INT_MAX;
            int lowBound = idx;
            for (int j = lowBound; j < i; j++)
            {
                // 可以到达i点，由于minDis[a]<minDis[b]如果a<b的话，因此第一个满足条件的即可
                if (nums[j] + j >= i)
                {                
                    idx = j;                
                    v = minDis[j] + 1;
                    break;
                }
            }
            minDis[i] = v;
        }
        return minDis[nums.size() - 1];
    }
};
```

# 46 Permutations 【搜索】

- 使用set记录所有的元素
- 使用map记录元素出现的次数，防止出现冗余

```
class Solution {
public:
    
    vector<vector<int> >  vs;
    vector<int> v;
    void solve(vector<int> s, int idx, map<int, int> m,set<int> si)
    {
        if (idx == s.size())
        {
            vs.push_back(v);
            return;
        }
        for (auto it = si.begin();it!=si.end();++it)
        {
            if (m[*it] > 0)
            {
                v.push_back(*it);
                m[*it]--;
                solve(s, idx + 1, m,si);
                m[*it]++;
                v.pop_back();
            }
        }
    }
    
    vector<vector<int>> permute(vector<int>& nums) {
        v.clear();
        vs.clear();       
        // 使用map存次数
        map<int, int> mi;
        // 使用set存出现的数字
        set<int> si;
        for (auto c : nums)            
        {
            mi[c] ++;
            si.insert(c);
        }
        solve(nums, 0, mi,si);
        return vs;
    }
};
```

# 47 Permutations II 【同样的题目，只是数字可能会重复，代码是相同】

- 加引用可以很大程度提升速度

```
class Solution {
public:

    vector<vector<int> >  vs;
    vector<int> v;
    void solve(vector<int> s, int idx, map<int, int> &m,set<int> &si)
    {
        if (idx == s.size())
        {
            vs.push_back(v);
            return;
        }
        for (auto it = si.begin();it!=si.end();++it)
        {
            if (m[*it] > 0)
            {
                v.push_back(*it);
                m[*it]--;
                solve(s, idx + 1, m,si);
                m[*it]++;
                v.pop_back();
            }
        }
    }
    
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        v.clear();
        vs.clear();       
        // 使用map存次数
        map<int, int> mi;
        // 使用set存出现的数字
        set<int> si;
        for (auto c : nums)            
        {
            mi[c] ++;
            si.insert(c);
        }
        solve(nums, 0, mi,si);
        return vs;
    }
    
};
```

# 48 Rotate Image 【矩阵操作】

## 方法一
- 单个旋转一圈

```
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n / 2; ++i)
        {
            for (int j = i; j < n - i-1; ++j)
            {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[n - 1 - j][i];
                matrix[n - 1 - j][i] = matrix[n-1-i][n-1-j];
                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];
                matrix[j][n - 1 - i] = tmp;
            }
        }
    }
};
```

## 方法二
- 先按右对角线进行翻转
- 然后进行上下翻转，同样可以达到旋转功能

```
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for(int i = 0; i < n - 1; i++){//i只能取到 n - 2, 因为n - 1是对称轴
            for(int j = 0; j < n - 1 - i; j++){//j只能取到n - 1 - i, 在对称轴的左边
                swap(matrix[i][j], matrix[n - 1 - j][n - 1 - i]);
            }
        }
        for(int i = 0; i < n / 2; i++){//i只能取到横向中间轴的上面
            for(int j = 0; j < n; j++){//j可以取到所有值
                swap(matrix[i][j], matrix[n - 1 - i][j]);//按横向轴翻转，j不变；i变为n-1-i
            }
        }
    }
};
```

## 方法三
- 先按作对角线进行翻转
- 然后进行左右翻转，达到同样旋转功能

```
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for(int i = 0; i < n; i++){
            for(int j = i + 1; j < n; j++){//j取i - 1, 因为对称轴是（i,i）
                swap(matrix[i][j], matrix[j][i]);
            }
            reverse(matrix[i].begin(), matrix[i].end());//按竖向中轴线翻转 直接按行reverse即可
        }
    }
};
```


# 49 Group Anagrams 【哈希】

- 对单词的字母进行计数
- 将数组转为字符串然后进行哈希
- 获得需要结果

```
class Solution {
public:
// 转化为字符串进行哈希
    string toString(vector<int> v)
    {
        string s;
        for (auto i : v)
        {
            s += to_string(i);
            s += "_";
        }
        return s;
    }

    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string> > mvv;
        for (auto s : strs)
        {
            vector<int> v(26,0);
            for (auto c : s)
                v[c - 'a']++;
            string str = toString(v);
            mvv[str].push_back(s);
        }
        vector<vector<string> > vvs;
        for (auto d = mvv.begin(); d != mvv.end();++d)
        {
            vvs.push_back(d->second);
        }
        return vvs;
    }
};
```


# 50 Pow(x,n) 【分治法，数值计算重要】

- 使用分治法
- 任何数的0次方都是1
- 注意区分正负
- **如果递归式相同，减小递归式的书写，能合并的用一个值代替，减少分支数量**

```
class Solution {
public:

    double solve(double x, int n) {
        if (n == 1)
            return x;
        if (n == 0)
            return 1;
        double v = solve(x, n / 2);
        if (n % 2)
            return v*v*x;
        else
            return v*v;
    }
    
    double myPow(double x, int n) {
        // 任何数的0次方都是1
        if (n == 0)
            return 1;
        if(n>0)
            return solve(x, n);
        if(n<0)
            return 1.0/solve(x,-n);
    }

};
```

